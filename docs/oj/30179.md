# T30179: 数字华容道（Hard Version）

Cycle Decomposition, http://cs101.openjudge.cn/practice/30179/

**总时间限制：2000ms，单个样例点时间限制：1000ms，内存限制：131072kB**

数字华容道的游戏玩法：在一个 $n \times n$ 的方格中放置 $1$ 到 $n^{2}-1$ 的所有数字（每个数字占据一空间），剩下一个空格（输入中用 $0$ 表示）。每次可以将与空格相邻的几个数字平移到空格处。游戏目标是尽可能快的将给定盘面还原到初始状态。（初始状态就是 $1$ 到 $n^{2}-1$ 按顺序填充每一行，空格在右下角的盘面）
例如一个可能的初始盘面是：

```txt
1 2 3 4
5 6 7 8
9 10 11 12
15 13 14 0
```

你的目标是通过平移数字，将盘面变成

```txt
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 0
```

的样子。

一天，小K正准备玩数字华容道，但是他不小心把盘面中的数字小方格都打翻在地了。虽然他将所有的数字都乱序排入了盘面中，但是这样的盘面是不一定有解的，所以他想请你判断一下这个盘面是否有解。

**输入**

第 $1$ 行：一个整数 $t$ ，$(1\leq t\leq 100)$，表示样例数目。
接下来对于每个样例：
第 $1$ 行：一个整数 $n$ ，$(2\leq n \leq 1000)$ 。（你就不要问小K是怎么把一百万个小方格捡起来的了）
第 $2$ 行到第 $n+1$ 行： $n$ 个整数，表示盘面。
数据保证每一个测试点都有 $\max(n^{2}) \times t \leq 10^7$。

**输出**

输出 $t$ 行。对于每一个样例，如果盘面有解，输出yes，否则输出no

样例输入

``` txt
2
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 0
2
2 1
3 0
```

样例输出

```txt
yes
no
```

（注：此题与Easy Version唯一的不同之处在于Hard Version的每一个输入文件都有多个样例，而Easy Version只有一个。）

**提示：**

tags: math, cycle decomposition
hint: 一个经典的智力问题。
现在有100个囚犯被囚禁，典狱长准备和他们玩一个游戏：有一百张写有 $1-100$ 号码的纸条被倒扣在一百个编号 $1-100$ 的盒子中。每个囚犯可以打开 $50$ 个盒子，但是所有囚犯在打开完盒子后不能与其他囚犯交流。如果所有囚犯都能找到自己的号码对应的纸条，他们就能成功逃脱。否则他们就都会被囚禁终生。如果每个囚犯都只是随机的打开 $50$ 个盒子，则他们能逃生的概率仅为 $0.5^{100}$ ，微乎其微。但是一个聪明的囚犯提出了一个方案：每个人都打开自己的号码对应的盒子，找到下面纸条上的号码，然后打开对应号码的盒子，如此往复，直到找到自己的号码为止。这样做可以显著的将逃生概率增加到 $30\%$ 左右。 
数学上，我们可以把从一个数移动到这个数对应位置的下一个数，如此往复，最终连回自己的结构称为循环（cycle）。比如说 2 3 1就是一个循环，它实际表示了$$
2\to 3\to 1 \to 2
$$在囚犯问题中，所有号码相当于组成了一个全排列。所有囚犯寻找自己号码的过程就相当于在全排列的各个不同循环中移动一圈。可以证明，一个全排列可以被唯一分解为许多不相交（不共用元素）的循环。
循环的性质：一个有 $n$ 个数的循环可以通过 $n-1$ 次元素交换变回递增的序列。比如循环 2 3 1 就可以通过先交换 $2$ 和 $3$ ，再交换 $3$ 和 $1$ 得到递增序列 1 2 3。



超时主要有三个原因：

1.  **算法复杂度过高**：归并排序求逆序对的复杂度是 $O(K \log K)$（其中 $K=N^2$）。在 Python 中，处理 $10^7$ 规模的数据，递归加列表切片（`left = a[:mid]`）的开销非常巨大，无法在 2 秒内跑完。
2.  **内存分配频繁**：归并排序中的切片操作会不断创建新的列表对象，导致大量的内存分配和垃圾回收耗时。
3.  **IO 效率**：虽然使用了 `readline`，但在大循环中频繁调用 `map` 和 `split` 还可以进一步优化。

**优化方案：置换环分解 (Cycle Decomposition)**

不需要真正计算逆序对的数量，只需要知道它的**奇偶性**。
**逆序对的奇偶性** 等同于 **(数组长度 - 置换环的数量) 的奇偶性**。

这个算法是 **$O(N^2)$ 的线性时间复杂度**，比归并排序快得多，且不需要递归。

优化后的代码

```python
import sys

# 提高递归深度，虽然本解法主要通过迭代优化，但保留以防万一
sys.setrecursionlimit(20000)

def solve():
    # 1. 使用生成器处理输入，避免一次性 split 导致内存超限
    def input_gen():
        for line in sys.stdin:
            for token in line.split():
                yield token

    tokens = input_gen()
    
    try:
        t_str = next(tokens)
    except StopIteration:
        return
        
    t = int(t_str)
    output = []
    
    for _ in range(t):
        try:
            n_str = next(tokens)
        except StopIteration:
            break
        n = int(n_str)
        total = n * n
        
        # 2. 高效读取整个网格
        # 直接读取 n*n 个数，比嵌套循环快
        grid = [int(next(tokens)) for _ in range(total)]
        
        # 3. 找到 0 的位置并计算行号
        # list.index 是 C 语言实现的，非常快
        zero_pos = grid.index(0)
        
        # 计算 0 所在的行号（从下往上数，最底下是第 1 行）
        # zero_pos // n 得到从上往下数(0-based)的行号
        # n=4, idx=15 => row_top=3 => row_bottom = 4 - 3 = 1
        row_from_bottom = n - (zero_pos // n)
        
        # 4. 移除 0，形成纯数字序列
        # 这一步是为了计算置换环
        # 使用切片拼接比 del 或 remove 在某些情况下更可控，或者直接 pop
        # 由于 grid 之后不用了，pop 是 O(N) 的
        grid.pop(zero_pos)
        
        # 5. 计算置换环 (Cycle Decomposition)
        # 时间复杂度 O(N^2)，只需要遍历一遍
        # 数组中的值范围是 1 到 n*n-1
        # 目标状态：值 v 应该在索引 v-1 处
        
        visited = bytearray(total) # 使用 bytearray 节省内存
        cycles = 0
        arr_len = total - 1
        
        for i in range(arr_len):
            if not visited[i]:
                # 发现一个新的环
                cycles += 1
                curr = i
                while not visited[curr]:
                    visited[curr] = 1
                    # 当前位置的值是 v，它应该要去的地方是 v-1
                    # 所以我们将指针移动到 grid[curr] - 1
                    curr = grid[curr] - 1
        
        # 还原数组所需的交换次数 = 数组长度 - 环的数量
        # 交换次数的奇偶性 == 逆序对的奇偶性
        swaps = arr_len - cycles
        
        # 6. 判定逻辑
        # N 为奇数：有解 <==> 逆序对(交换次数)为偶数
        # N 为偶数：有解 <==> (逆序对 + 0 所在行数_从下往上) 为奇数
        
        if n % 2 == 1:
            if swaps % 2 == 0:
                output.append("yes")
            else:
                output.append("no")
        else:
            if (swaps + row_from_bottom) % 2 == 1:
                output.append("yes")
            else:
                output.append("no")

    print('\n'.join(output))

if __name__ == "__main__":
    solve()
```

代码修改详解

1.  **移除归并排序**：用 `置换环` 算法替代。归并排序在 Python 中因为切片和递归太慢，置换环只需要简单的数组索引跳转，是纯线性的 $O(N^2)$。
2.  **输入优化**：使用了 `input_gen` 生成器。你的 `read().split()` 在 $N=1000$ 的多个测试用例下会产生非常大的内存压力，改成流式读取更安全。
3.  **数学原理对齐**：
    *   **置换环原理**：如果一个排列由 $C$ 个不相交的环组成，元素总数为 $L$，那么将它还原成有序序列最少需要 $L-C$ 次交换。**交换次数的奇偶性与逆序对数的奇偶性完全一致**。
    *   **判定条件**：使用了标准的“从下往上数行号”的判定公式。
        *   $N$ 为奇数：`swaps` 必须是偶数。
        *   $N$ 为偶数：`(swaps + row_from_bottom)` 必须是奇数。

这个版本在处理 $1000 \times 1000$ 的矩阵时，速度会比归并排序快 10 倍以上。


