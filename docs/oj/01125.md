# T01125: Stockbroker Grapevine

dijkstra, http://cs101.openjudge.cn/practice/01125/

Stockbrokers are known to overreact to rumours. You have been contracted to develop a method of spreading disinformation amongst the stockbrokers to give your employer the tactical edge in the stock market. For maximum effect, you have to spread the rumours in the fastest possible way.

Unfortunately for you, stockbrokers only trust information coming from their "Trusted sources" This means you have to take into account the structure of their contacts when starting a rumour. It takes a certain amount of time for a specific stockbroker to pass the rumour on to each of his colleagues. Your task will be to write a program that tells you which stockbroker to choose as your starting point for the rumour, as well as the time it will take for the rumour to spread throughout the stockbroker community. This duration is measured as the time needed for the last person to receive the information.

**输入**

Your program will input data for different sets of stockbrokers. Each set starts with a line with the number of stockbrokers. Following this is a line for each stockbroker which contains the number of people who they have contact with, who these people are, and the time taken for them to pass the message to each person. The format of each stockbroker line is as follows: The line starts with the number of contacts (n), followed by n pairs of integers, one pair for each contact. Each pair lists first a number referring to the contact (e.g. a '1' means person number one in the set), followed by the time in minutes taken to pass a message to that person. There are no special punctuation symbols or spacing rules.

Each person is numbered 1 through to the number of stockbrokers. The time taken to pass the message on will be between 1 and 10 minutes (inclusive), and the number of contacts will range between 0 and one less than the number of stockbrokers. The number of stockbrokers will range from 1 to 100. The input is terminated by a set of stockbrokers containing 0 (zero) people.

**输出**

For each set of data, your program must output a single line containing the person who results in the fastest message transmission, and how long before the last person will receive any given message after you give it to this person, measured in integer minutes.
It is possible that your program will receive a network of connections that excludes some persons, i.e. some people may be unreachable. If your program detects such a broken network, simply output the message "disjoint". Note that the time taken to pass the message from person A to person B is not necessarily the same as the time taken to pass it from B to A, if such transmission is possible at all. 

样例输入

```
3
2 2 4 3 5
2 1 2 3 6
2 1 2 2 2
5
3 4 4 2 8 5 3
1 5 8
4 1 6 4 10 2 7 5 2
0
2 2 5 1 5
0
```

样例输出

```
3 2
3 10
```

来源

Southern African 2001




【陈子良 25物理学院】这题我甚至写完才发现是Dijkstra。突然发现从时间角度理解Dijkstra比从价格开销角度好理解。首先选一个人作为谣言来源，想象一条逐渐增大的时间轴，一旦有一个人在当前时刻接受到了谣言，就会马上将其辐射传播出去，因此要更新其周围的人接受到谣言的时刻，然后选下一个接受到谣言的人。这样就能很自然地写出Dijkstra了。


```python
import heapq
while True:
    n=int(input())
    if n==0:
        break
    contact=[{}]
    for _ in range(n):
        list1=list(map(int,input().split()))
        dict1={}
        for i in range((len(list1)-1)//2):
            dict1[list1[2*i+1]]=list1[2*i+2]
        contact.append(dict1)
    i0=0
    s=float('inf')
    for i in range(1,n+1):
        heap=[(0,i)]
        heapq.heapify(heap)
        time=[0]+[float('inf')]*n
        time[i]=0
        condition=[True]+[False]*n
        while heap:
            t,j=heapq.heappop(heap)
            if condition[j]:
                continue
            condition[j]=True
            if sum(condition)==n+1:
                if max(time)<s:
                    s=max(time)
                    i0=i
                break
            for k in contact[j]:
                t1=t+contact[j][k]
                if not condition[k] and time[k]>t1:
                    time[k]=t1
                    heapq.heappush(heap,(t1,k))
    if i0==0:
        print('disjoint')
    else:
        print(f'{i0} {s}')
```


