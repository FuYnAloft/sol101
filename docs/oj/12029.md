# M12029: æ°´æ·¹ä¸ƒå†›

bfs, dfs, http://cs101.openjudge.cn/pctbook/M12029/

éšç€æœ€åé€šç‰’çš„é€’å‡ºï¼ŒCå›½çš„æ€»æ”»ä¹Ÿå¼€å§‹äº†ï¼Œç”±äºCå›½åœ¨åœ°å½¢ä¸Šçš„ä¼˜åŠ¿ï¼ŒCå›½æ€»å¸ä»¤ä¸‹ä»¤é‡‡ç”¨æ°´æ”»ï¼Œå‰¿ç­Aå›½æœ€åçš„æœ‰ç”ŸåŠ›é‡ã€‚ 
åœ°å½¢å›¾æ˜¯ä¸€ä¸ªM*Nçš„çŸ©é˜µï¼ŒçŸ©é˜µä¸Šæ¯ä¸€ä¸ªç‚¹éƒ½å¯¹åº”ç€å½“å‰ç‚¹çš„é«˜åº¦ã€‚Cå›½æ€»å¸ä»¤å°†é€‰æ‹©è‹¥å¹²ä¸ªç‚¹è¿›è¡Œæ”¾æ°´ã€‚æ ¹æ®æ°´å¾€ä½å¤„æµçš„ç‰¹æ€§ï¼Œæ°´å¯ä»¥å¾€å››ä¸ªæ–¹å‘çš„æµåŠ¨ï¼Œè¢«æ·¹çš„åœ°æ–¹çš„æ°´é¢é«˜åº¦ä¾¿å’Œæ”¾æ°´ç‚¹çš„é«˜åº¦ä¸€æ ·ã€‚ç„¶è€Œï¼ŒAå›½ä¸æ˜¯ä¸€é©¬å¹³å·çš„ï¼Œæ‰€ä»¥æ€»ä¼šæœ‰åœ°æ–¹æ˜¯æ·¹æ²¡ä¸åˆ°çš„ã€‚ä½ çš„ä»»åŠ¡å¾ˆç®€å•ï¼Œåˆ¤æ–­ä¸€ä¸‹Aå›½å¸ä»¤éƒ¨ä¼šä¸ä¼šè¢«æ·¹æ²¡æ‰ã€‚ 
æˆ‘ä»¬å°†ç»™ä½ å®Œæ•´çš„åœ°å½¢å›¾ï¼Œç„¶åç»™å‡ºAå›½å¸ä»¤éƒ¨æ‰€åœ¨ä½ç½®ï¼Œç»™å‡ºCå›½å°†åœ¨å“ªå‡ ä¸ªç‚¹è¿›è¡Œæ”¾æ°´æ“ä½œã€‚ä½ æ‰€éœ€è¦çš„ï¼Œå°±æ˜¯ç»™å‡ºAå›½å¸ä»¤éƒ¨ä¼šä¸ä¼šè¢«æ°´æ·¹ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œï¼šä¸€ä¸ªæ•´æ•°Kï¼Œä»£è¡¨æ•°æ®ç»„æ•°ã€‚ 
å¯¹äºæ¯ä¸€ç»„æ•°æ®ï¼š 
ç¬¬1è¡Œï¼šç¬¦åˆé¢˜ç›®æè¿°çš„ä¸¤ä¸ªæ•´æ•°ï¼ŒM(0 < M <= 200)ã€N(0 < N <= 200)ã€‚ 
ç¬¬2è¡Œè‡³M+1è¡Œï¼šæ¯è¡ŒNä¸ªæ•°ï¼Œä»¥ç©ºæ ¼åˆ†å¼€ï¼Œä»£è¡¨è¿™ä¸ªçŸ©é˜µä¸Šçš„å„ç‚¹çš„é«˜åº¦å€¼H(0 <= H <= 1000)ã€‚ 
ç¬¬M+2è¡Œï¼šä¸¤ä¸ªæ•´æ•°I(0 < I <= M)ã€J(0 < J <= N)ï¼Œä»£è¡¨å¸ä»¤éƒ¨æ‰€åœ¨ä½ç½®ã€‚ 
ç¬¬M+3è¡Œï¼šä¸€ä¸ªæ•´æ•°P(0 < P <= M * N)ï¼Œä»£è¡¨æ”¾æ°´ç‚¹ä¸ªæ•°ã€‚ 
ç¬¬M+4è¡Œè‡³M+P+4è¡Œï¼šæ¯è¡Œä¸¤ä¸ªæ•´æ•°X(0 < X <= M)ã€Y(0 < Y <= N)ï¼Œä»£è¡¨æ”¾æ°´ç‚¹ã€‚

**è¾“å‡º**

å¯¹äºæ¯ç»„æ•°æ®ï¼Œè¾“å‡ºä¸€è¡Œï¼Œå¦‚æœè¢«æ·¹åˆ™è¾“å‡ºYesï¼Œæ²¡æœ‰åˆ™è¾“å‡ºNoã€‚

æ ·ä¾‹è¾“å…¥

```
1
5 5
1 1 1 1 1
1 0 0 0 1
1 0 1 0 1
1 0 0 0 1
1 1 1 1 1
3 3
2
1 1
2 2
```

æ ·ä¾‹è¾“å‡º

```
No
```

æç¤º

æ ·ä¾‹ä¸­å·¦ä¸Šè§’çš„ä½ç½®æ˜¯(1, 1),å³ä¸Šè§’çš„ä½ç½®æ˜¯(1, 5), å³ä¸‹è§’çš„ä½ç½®æ˜¯(5, 5)



æ ¹æ®æ ·ä¾‹ï¼Œå¯ä»¥è¿™æ ·ç†è§£ï¼šå¦‚æœå¸ä»¤éƒ¨ä¸å‘¨å›´æ°´ç­‰é«˜ï¼Œä¸ç®—æ·¹æ²¡ã€‚

ä¸ç”¨visitedçš„åŸå› ï¼Œæœ‰çš„ç‚¹åœ¨æŸäº›æƒ…å†µä¸‹ä¹Ÿéœ€è¦é‡æ–°éå†ã€‚æ¯”å¦‚ä¹‹å‰æ·¹æ²¡çš„é«˜åº¦ä¸ºhï¼Œä¹‹åæ”¾æ°´çš„é«˜åº¦H>hï¼Œæ­¤æ—¶å°±éœ€è¦é‡æ–°æ·¹æ²¡ã€‚å³å¯ä»¥ä¸ç”¨visitedï¼Œç›´æ¥ç”¨water_heightçŸ©é˜µï¼ˆæ¯æ¬¡æ´ªæ³›æ›´æ–°ï¼‰ï¼Œåªè¦æ‰©å±•ç‚¹çš„é«˜åº¦å°äºå½“å‰water_height_valueã€‚



bfså®ç°

```python
from collections import deque
import sys
input = sys.stdin.read

# åˆ¤æ–­åæ ‡æ˜¯å¦æœ‰æ•ˆ
def is_valid(x, y, m, n):
    return 0 <= x < m and 0 <= y < n

# å¹¿åº¦ä¼˜å…ˆæœç´¢æ¨¡æ‹Ÿæ°´æµ
def bfs(start_x, start_y, start_height, m, n, h, water_height):
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    q = deque([(start_x, start_y, start_height)])
    water_height[start_x][start_y] = start_height

    while q:
        x, y, height = q.popleft()
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if is_valid(nx, ny, m, n) and h[nx][ny] < height:
                if water_height[nx][ny] < height:
                    water_height[nx][ny] = height
                    q.append((nx, ny, height))

# ä¸»å‡½æ•°
def main():
    data = input().split()  # å¿«é€Ÿè¯»å–æ‰€æœ‰è¾“å…¥æ•°æ®
    idx = 0
    k = int(data[idx])
    idx += 1
    results = []

    for _ in range(k):
        m, n = map(int, data[idx:idx + 2])
        idx += 2
        h = []
        for i in range(m):
            h.append(list(map(int, data[idx:idx + n])))
            idx += n
        water_height = [[0] * n for _ in range(m)]

        i, j = map(int, data[idx:idx + 2])
        idx += 2
        i, j = i - 1, j - 1

        p = int(data[idx])
        idx += 1

        for _ in range(p):
            x, y = map(int, data[idx:idx + 2])
            idx += 2
            x, y = x - 1, y - 1

            bfs(x, y, h[x][y], m, n, h, water_height)

        results.append("Yes" if water_height[i][j] > 0 else "No")

    sys.stdout.write("\n".join(results) + "\n")

if __name__ == "__main__":
    main()
```



**æ€è·¯æ˜¯å¯¹çš„**ï¼Œä½†æ€§èƒ½ä¸Šæœ‰ä¸€ä¸ªæ˜æ˜¾ç“¶é¢ˆï¼š

> æ¯ä¸€ä¸ªæ”¾æ°´ç‚¹éƒ½å•ç‹¬åšä¸€æ¬¡ BFSï¼Œåœ¨æœ€åæƒ…å†µä¸‹ï¼š$P = MN = 4\times10^4$ï¼Œæ¯æ¬¡ BFS æ‰«å…¨å›¾â†’ TLE

æœ¬è´¨ä¼˜åŒ–ç‰ˆï¼Œä¿æŒä½ â€œwater_height çŸ©é˜µã€ä¸ç”¨ visitedã€å¯é‡å¤æ·¹æ²¡â€çš„æ€æƒ³ï¼Œä½†æŠŠå¤æ‚åº¦ä»
$O(P \cdot MN) \rightarrow O(MN \log MN)$

------

æ ¸å¿ƒä¼˜åŒ–æ€è·¯

ğŸ‘‰ **å¤šæº + æœ€å¤§å † BFSï¼ˆåå‘ Dijkstraï¼‰**

- æ¯ä¸ªæ”¾æ°´ç‚¹æ˜¯ä¸€ä¸ªâ€œæ°´æºâ€ï¼Œæ°´ä½ = è¯¥ç‚¹é«˜åº¦
- æ°´åªèƒ½ä» **é«˜ â†’ ä½** æµ
- å¯¹æ¯ä¸ªç‚¹ï¼Œåªéœ€è¦çŸ¥é“ï¼š
  **å®ƒèƒ½è¢«æ·¹åˆ°çš„æœ€é«˜æ°´ä½æ˜¯å¤šå°‘**

è¿™æ­£æ˜¯ä¸€ä¸ªï¼šåœ¨é«˜åº¦çº¦æŸä¸‹ï¼Œæœ€å¤§åŒ– water_height çš„ä¼ æ’­é—®é¢˜

### æ ‡å‡† AC è§£æ³•ï¼ˆæ¨èï¼‰

```python
import sys
import heapq

input = sys.stdin.read

def main():
    data = list(map(int, input().split()))
    idx = 0
    K = data[idx]
    idx += 1
    out = []

    for _ in range(K):
        M, N = data[idx], data[idx+1]
        idx += 2

        h = []
        for _ in range(M):
            h.append(data[idx:idx+N])
            idx += N

        I, J = data[idx]-1, data[idx+1]-1
        idx += 2

        P = data[idx]
        idx += 1

        water = [[-1]*N for _ in range(M)]
        pq = []  # max-heap: (-water_height, x, y)

        for _ in range(P):
            x, y = data[idx]-1, data[idx+1]-1
            idx += 2
            w = h[x][y]
            if w > water[x][y]:
                water[x][y] = w
                heapq.heappush(pq, (-w, x, y))

        dx = (-1, 1, 0, 0)
        dy = (0, 0, -1, 1)

        flooded = False

        while pq:
            w, x, y = heapq.heappop(pq)
            w = -w

            if w < water[x][y]:
                continue

            if x == I and y == J and w > h[I][J]:
                flooded = True
                break

            for d in range(4):
                nx, ny = x+dx[d], y+dy[d]
                if 0 <= nx < M and 0 <= ny < N:
                    if h[nx][ny] < w and w > water[nx][ny]:
                        water[nx][ny] = w
                        heapq.heappush(pq, (-w, nx, ny))

        out.append("Yes" if flooded else "No")

    print("\n".join(out))


if __name__ == "__main__":
    main()
```

å¤æ‚åº¦åˆ†æ

- æ¯ä¸ªç‚¹æœ€å¤šè¢«æ›´æ–°å‡ æ¬¡ï¼ˆå †ä¼˜åŒ–ï¼‰
- æ€»å¤æ‚åº¦ï¼š$O(MN \log MN)$ï¼Œ$200 \times 200$ è½»æ¾è¿‡

------

æ€»ç»“

> è¿™æ˜¯ä¸€ä¸ª**å¤šæºã€å•è°ƒçº¦æŸã€æœ€å¤§å€¼ä¼ æ’­**é—®é¢˜
> ç”¨ **æœ€å¤§å † BFSï¼ˆåå‘ Dijkstraï¼‰** æ˜¯æœ€è‡ªç„¶ã€æœ€ç¨³å¦¥çš„è§£æ³•





ä»£ç å…³é”®ç‚¹æ³¨é‡Šè¯´æ˜ï¼š

1.  **è¾“å…¥å¤„ç†**ï¼šä½¿ç”¨ `sys.stdin.read().split()` å°†æ‰€æœ‰è¾“å…¥è¯»å…¥å†…å­˜å¹¶è½¬ä¸ºè¿­ä»£å™¨ã€‚è¿™æ¯”ä¸€è¡Œè¡Œ `input()` è¯»å…¥è¦å¿«å¾—å¤šï¼Œä¸”èƒ½å¾ˆå¥½åœ°å¤„ç†ä¸åŒæ“ä½œç³»ç»Ÿä¸‹çš„æ¢è¡Œç¬¦é—®é¢˜ã€‚
2.  **åæ ‡è½¬æ¢**ï¼šé¢˜ç›®ç»™å‡ºçš„æ˜¯ 1-basedï¼ˆä»1å¼€å§‹ï¼‰çš„åæ ‡ï¼ŒPython åˆ—è¡¨æ˜¯ 0-basedï¼ˆä»0å¼€å§‹ï¼‰ï¼Œæ‰€ä»¥åœ¨è¯»å– $I, J, X, Y$ æ—¶éƒ½è¦å‡ 1ã€‚
3.  **é€†å‘ BFS**ï¼š
    *   å¦‚æœæˆ‘ä»¬æ­£å‘æ¨¡æ‹Ÿæ°´æµï¼ˆä»æ”¾æ°´ç‚¹æµå‘ä½å¤„ï¼‰ï¼Œéœ€è¦å¯¹æ¯ä¸€ä¸ªæ”¾æ°´ç‚¹åšä¸€æ¬¡æœç´¢ï¼Œå®¹æ˜“è¶…æ—¶ã€‚
    *   **é€†å‘æ€è·¯**ï¼šå¦‚æœæ°´èƒ½ä» A æµåˆ° Bï¼ˆ$H_A \ge \dots \ge H_B$ï¼‰ï¼Œé‚£ä¹ˆä¸€å®šèƒ½ä» B é€†ç€èµ°åˆ° Aï¼ˆ$H_B \le \dots \le H_A$ï¼‰ã€‚
    *   æˆ‘ä»¬åªä»ç»ˆç‚¹ï¼ˆå¸ä»¤éƒ¨ï¼‰å‡ºå‘è¿›è¡Œä¸€æ¬¡ BFSï¼Œæ ‡è®°æ‰€æœ‰èƒ½é€šè¿‡â€œçˆ¬å±±â€åˆ°è¾¾çš„ç‚¹ã€‚
4.  **åˆ¤å®š**ï¼šæœ€ååªéœ€ $O(P)$ çš„æ—¶é—´éå†ä¸€ä¸‹æ”¾æ°´ç‚¹åˆ—è¡¨ï¼Œçœ‹æœ‰æ²¡æœ‰æ”¾æ°´ç‚¹è½åœ¨äº†æˆ‘ä»¬æ ‡è®°çš„åŒºåŸŸå†…å³å¯ã€‚





```python
from collections import deque

for _ in range(int(input())):
    m, n = map(int, input().split())
    # åˆ›å»ºç½‘æ ¼ï¼Œæ·»åŠ è¾¹ç•Œ
    l = [[1000] * (n + 2)]
    for i in range(m):
        l.append([1000] + list(map(int, input().split())) + [1000])
    l.append([1000] * (n + 2))
    I, J = map(int, input().split())
    P = int(input())

    found = False
    for i in range(P):
        x, y = map(int, input().split())
        # å¦‚æœå·²ç»æ‰¾åˆ°ï¼Œè·³è¿‡åç»­æ”¾æ°´ç‚¹
        if found:
            continue
        use = [[0] * (n + 2) for j in range(m + 2)]
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        # BFSé˜Ÿåˆ—
        queue = deque()
        # æ ‡è®°èµ·å§‹ç‚¹å¹¶åŠ å…¥é˜Ÿåˆ—
        use[x][y] = 1
        queue.append((x, y))
        h = l[x][y]  # æ”¾æ°´ç‚¹é«˜åº¦

        while queue:
            cx, cy = queue.popleft()
            for dx, dy in directions:
                nx, ny = cx + dx, cy + dy
                # æ£€æŸ¥ç›¸é‚»ç‚¹æ˜¯å¦æœªè®¿é—®ä¸”é«˜åº¦å°äºæ”¾æ°´ç‚¹é«˜åº¦
                if l[nx][ny] < h and use[nx][ny] == 0:
                    use[nx][ny] = 1
                    queue.append((nx, ny))
        # æ£€æŸ¥å¸ä»¤éƒ¨æ˜¯å¦è¢«æ·¹æ²¡
        if use[I][J] == 1:
            print("Yes")
            found = True
    if not found:
        print("No")
```



dfså®ç°

```python
import sys

sys.setrecursionlimit(300000)
input = sys.stdin.read


# åˆ¤æ–­åæ ‡æ˜¯å¦æœ‰æ•ˆ
def is_valid(x, y, m, n):
    return 0 <= x < m and 0 <= y < n


# æ·±åº¦ä¼˜å…ˆæœç´¢æ¨¡æ‹Ÿæ°´æµ
def dfs(x, y, water_height_value, m, n, h, water_height):
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]

    for i in range(4):
        nx, ny = x + dx[i], y + dy[i]
        if is_valid(nx, ny, m, n) and h[nx][ny] < water_height_value:
            if water_height[nx][ny] < water_height_value:
                water_height[x][y] = water_height_value
                dfs(nx, ny, water_height_value, m, n, h, water_height)


# ä¸»å‡½æ•°
def main():
    data = input().split()  # å¿«é€Ÿè¯»å–æ‰€æœ‰è¾“å…¥æ•°æ®
    idx = 0
    k = int(data[idx])
    idx += 1
    results = []

    for _ in range(k):
        m, n = map(int, data[idx:idx + 2])
        idx += 2
        h = []
        for i in range(m):
            h.append(list(map(int, data[idx:idx + n])))
            idx += n
        water_height = [[0] * n for _ in range(m)]

        i, j = map(int, data[idx:idx + 2])
        idx += 2
        i, j = i - 1, j - 1

        p = int(data[idx])
        idx += 1

        for _ in range(p):
            x, y = map(int, data[idx:idx + 2])
            idx += 2
            x, y = x - 1, y - 1
            if h[x][y] <= h[i][j]:
                continue

            dfs(x, y, h[x][y], m, n, h, water_height)

        results.append("Yes" if water_height[i][j] > 0 else "No")

    sys.stdout.write("\n".join(results) + "\n")


if __name__ == "__main__":
    main()
```



dfsçš„è¿­ä»£å†™æ³•

```python
import sys

direction = [(1, 0), (0, 1), (-1, 0), (0, -1)]


def dfs(matrix, x, y, target_x, target_y):
    m, n = len(matrix), len(matrix[0])
    h = matrix[x][y]
    stack = [(x, y)]
    visited = [[False for _ in range(n)] for _ in range(m)]

    while stack:
        x, y = stack.pop()
        if x == target_x and y == target_y:
            return True
        visited[x][y] = True
        for dx, dy in direction:
            nx, ny = x + dx, y + dy
            if 0 <= nx < m and 0 <= ny < n:  # ç¡®ä¿æ–°åæ ‡åœ¨çŸ©é˜µèŒƒå›´å†…
                if not visited[nx][ny] and matrix[nx][ny] < h:  # å…è®¸æµå‘ç­‰é«˜æˆ–æ›´ä½çš„ä½ç½®
                    stack.append((nx, ny))

    return False


# è¯»å–å¹¶å¤„ç†è¾“å…¥
data = sys.stdin.read().split()
k = int(data[0])
id = 1
ans = []

for _ in range(k):
    m, n = int(data[id]), int(data[id + 1])
    id += 2
    matrix = [list(map(int, data[id + i * n:id + (i + 1) * n])) for i in range(m)]
    id += m * n
    a, b = int(data[id]) - 1, int(data[id + 1]) - 1
    id += 2
    p = int(data[id])
    id += 1
    pos = [(int(data[id + i * 2]) - 1, int(data[id + i * 2 + 1]) - 1) for i in range(p)]
    id += p * 2

    result = any(dfs(matrix, x, y, a, b) for x, y in pos)
    ans.append("Yes" if result else "No")

sys.stdout.write("\n".join(ans) + "\n")
```





```python
# é¢œé¼å ƒ(24n2400011125)
from sys import stdin
from collections import deque
get = map(int, stdin.read().split())
DIRECTIONS = ((0, 1), (0, -1), (1, 0), (-1, 0))
def bfs(x, y):
    if (x, y) == (I, J):
        return True
    h = mat[x][y]
    queue = deque()
    queue.append((x, y))
    while queue:
        px, py = queue.popleft()
        for dx, dy in DIRECTIONS:
            nx, ny = px + dx, py + dy
            if mat[nx][ny] < h:
                if (nx, ny) == (I, J):
                    return True
                queue.append((nx, ny))
                mat[nx][ny] = h
for _ in range(next(get)):
    yes = False
    M, N = next(get), next(get)
    mat = [[1e9 for i in range(N + 2)]] + [[1e9] + [0 for i in range(N)] + [1e9] for j in range(M)] + [[1e9 for i in range(N + 2)]]
    for i in range(1, 1 + M):
        for j in range(1, 1 + N):
            mat[i][j] = next(get)
    I, J = next(get), next(get)
    for i in range(next(get)):
        if yes:
            next(get)
            next(get)
        else:
            if bfs(next(get), next(get)):
                yes = True
    print("Yes" if yes else "No")
```




