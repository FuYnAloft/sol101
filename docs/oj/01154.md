# T01154: LETTERS

dfs, http://cs101.openjudge.cn/practice/01154/

A single-player game is played on a rectangular board divided in R rows and C columns. There is a single uppercase letter (A-Z) written in every position in the board.
Before the begging of the game there is a figure in the upper-left corner of the board (first row, first column). In every move, a player can move the figure to the one of the adjacent positions (up, down,left or right). Only constraint is that a figure cannot visit a position marked with the same letter twice.
The goal of the game is to play as many moves as possible.
Write a program that will calculate the maximal number of positions in the board the figure can visit in a single game.

**输入**

The first line of the input contains two integers R and C, separated by a single blank character, 1 <= R, S <= 20.
The following R lines contain S characters each. Each line represents one row in the board.

**输出**

The first and only line of the output should contain the maximal number of position in the board the figure can visit.

样例输入

```
3 6
HFDFFB
AJHGDH
DGAGEH
```

样例输出

```
6
```

来源

Croatia OI 2002 Regional Competition - Juniors




【陈子良 25物理学院】乍一看是广搜，但因为要记录走过的路径上的字母，因此结果与路径有关，要改成深搜。


```python
R,C=map(int,input().split())
grid=[]
for _ in range(R):
    grid.append(list(input()))
condition=[0]*26
def r(a):
    return ord(a)-65
def check(x,y):
    return 0<=x<=R-1 and 0<=y<=C-1
s=0
d=[[1,0],[-1,0],[0,1],[0,-1]]
def dfs(x,y,n):
    flag=True
    for i in range(4):
        x1=x+d[i][0]
        y1=y+d[i][1]
        if check(x1,y1):
            a=r(grid[x1][y1])
            if condition[a]==0:
                flag=False
                condition[a]=1
                dfs(x1,y1,n+1)
                condition[a]=0
    if flag:
        global s
        s=max(s,n)
        return
condition[r(grid[0][0])]=1
dfs(0,0,1)
print(s)
```

 
