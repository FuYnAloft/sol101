# 01062: 昂贵的聘礼

dfs, http://cs101.openjudge.cn/practice/01062/

年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说："嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。"探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。
为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的"优惠"Vi。如果两人地位等级差距超过了M，就不能"间接交易"。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。

**输入**

输入第一行是两个整数M，N（1 <= N <= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X < N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和"优惠价格"。

**输出**

输出最少需要的金币数。

样例输入

```
1 4
10000 3 2
2 8000
3 5000
1000 2 1
4 200
3000 2 1
4 200
50 2 0
```

样例输出

```
5250
```

来源: 浙江



与 25561: 2022决战双十一 类似的dfs。

```python
# 2300015881 赵凌哲 光华管理学院
def dfs(num, max_level, min_level):
    if item_list[num][3]:
        return -1
    if item_list[num][1] < max_level - m or item_list[num][1] > min_level + m:
        return -1
    item_list[num][3] = True
    max_level_updated = max(max_level, item_list[num][1])
    min_level_updated = min(min_level, item_list[num][1])
    price = item_list[num][0]
    for replace_item in item_list[num][2]:
        pr = dfs(replace_item[0], max_level_updated, min_level_updated)
        if pr == -1:
            continue
        else:
            price = min(price, replace_item[1] + pr)
    item_list[num][3] = False
    return price


m, n = map(int, input().split())
item_list = []
for i in range(n):
    p, l, x = map(int, input().split())
    replace_options = []
    for j in range(x):
        t, v = map(int, input().split())
        replace_options.append([t - 1, v])
    item_list.append([p, l, replace_options, False])
print(dfs(0, item_list[0][1], item_list[0][1]))
```

 

【陈子良 25物理学院】决战双十一的加强版，多了一个地位等级的约束。联系到之前刷LeetCode知道的最小栈，突发奇想建了最大栈和最小栈，然后可以用回溯的操作，妙哉。

```python
M,N=map(int,input().split())
dict1={}
for i in range(1,N+1):
    P,L,X=map(int,input().split())
    if i==1:
        L0=L
    l=[P,L,{}]
    for _ in range(X):
        T,V=map(int,input().split())
        l[2][T]=V
    dict1[i]=l
# 最大栈，最小栈
Mstack=[-float('inf')]
mstack=[float('inf')]
condition=[False]*(N+1)
def dfs(i):
    if condition[i]:
        return float('inf')
    P,L,dict2=dict1[i]
    M1=max(Mstack[-1],L)
    m1=min(mstack[-1],L)
    if M1-m1>M:
        return float('inf')
    if not dict2:
        return P
    Mstack.append(M1)
    mstack.append(m1)
    condition[i]=True
    b=P
    for j in dict2:
        b=min(b,dict2[j]+dfs(j))
    Mstack.pop()
    mstack.pop()
    condition[i]=False
    return b
print(dfs(1))
```




