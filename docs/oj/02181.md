# 02181: Jumping Cows

greedy, http://cs101.openjudge.cn/practice/02181/

Farmer John's cows would like to jump over the moon, just like the cows in their favorite nursery rhyme. Unfortunately, cows can not jump.

The local witch doctor has mixed up P (1 <= P <= 150,000) potions to aid the cows in their quest to jump. These potions must be administered exactly in the order they were created, though some may be skipped.

Each potion has a 'strength' (1 <= strength <= 500) that enhances the cows' jumping ability. Taking a potion during an odd time step increases the cows' jump; taking a potion during an even time step decreases the jump. Before taking any potions the cows' jumping ability is, of course, 0.

No potion can be taken twice, and once the cow has begun taking potions, one potion must be taken during each time step, starting at time 1. One or more potions may be skipped in each turn.

Determine which potions to take to get the highest jump.

**输入**

\* Line 1: A single integer, P

\* Lines 2..P+1: Each line contains a single integer that is the strength of a potion. Line 2 gives the strength of the first potion; line 3 gives the strength of the second potion; and so on.

**输出**

\* Line 1: A single integer that is the maximum possible jump.

样例输入

```
8
7
2
1
8
4
3
5
6
```

样例输出

```
17
```

来源

USACO 2003 U S Open Orange



与 26976: 摆动序列 一样的方法。

```python
# 2300010763	胡睿诚	数学科学学院
P = int(input())
potions = []
for i in range(P):
    potions.append((int(input())))
result = 0
sign = 1
for i in range(P-1):
    if (potions[i + 1] - potions[i]) * sign < 0:
        result += sign * potions[i]
        sign = -sign
if sign == 1:
    result += potions[P-1]
print(result)
```



```python
from itertools import groupby

n = int(input())
#n = 28
raw_p = [0] + [int(input()) for _ in range(n)]
#raw_p = [13,15,10,16,4,4,12,10,17,9,12,7,3,7,7,5,13,4,9,12,\
#           18,8,14,18,10,19,16,18]
#my_list = [1, 4, 4,2, 2, 3, 4, 4, 4, 5, 6, 6, 7]
p = [x[0] for x in groupby(raw_p)]

ans = 0
evenF = False
n = len(p) - 1
for i in range(1, n):
    if ans == 0 and p[i] > p[i+1]:
        ans += p[i]
        evenF = False
        #print('+', p[i], end='')
        continue
    
    if p[i] <= p[i-1] and p[i] <= p[i+1]:
        ans -= p[i]
        evenF = True
        #print('-', p[i], end='')
        if i==n-1:
            ans += p[i+1]
            break
        continue
    
    if evenF and i==n-1 and p[i] <= p[i+1]:
        ans += p[i+1]
        #print('+', p[i], end='')
        evenF = False
        break
    
    if p[i] >= p[i-1] and p[i] >= p[i+1]:
        ans += p[i]
        evenF = False
        #print('+', p[i], end='')

#print()
print(ans)
```


