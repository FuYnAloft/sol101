# 01026: Cipher

http://cs101.openjudge.cn/practice/01026/

同 http://cs101.openjudge.cn/practice/02818/

Bob and Alice started to use a brand-new encoding scheme. Surprisingly it is not a Public Key Cryptosystem, but their encoding and decoding is based on secret keys. They chose the secret key at their last meeting in Philadelphia on February 16th, 1996. They chose as a secret key a sequence of n distinct integers, a1 ; . . .; an, greater than zero and less or equal to n. The encoding is based on the following principle. The message is written down below the key, so that characters in the message and numbers in the key are correspondingly aligned. Character in the message at the position i is written in the encoded message at the position ai, where ai is the corresponding number in the key. And then the encoded message is encoded in the same way. This process is repeated k times. After kth encoding they exchange their message.

The length of the message is always less or equal than n. If the message is shorter than n, then spaces are added to the end of the message to get the message with the length n.

Help Alice and Bob and write program which reads the key and then a sequence of pairs consisting of k and message to be encoded k times and produces a list of encoded messages. 

**输入**

The input file consists of several blocks. Each block has a number 0 < n <= 200 in the first line. The next line contains a sequence of n numbers pairwise distinct and each greater than zero and less or equal than n. Next lines contain integer number k and one message of ascii characters separated by one space. The lines are ended with eol, this eol does not belong to the message. The block ends with the separate line with the number 0. After the last block there is in separate line the number 0. 

**输出**

Output is divided into blocks corresponding to the input blocks. Each block contains the encoded input messages in the same order as in input file. Each encoded message in the output file has the lenght n. After each block there is one empty line. 

样例输入

```
10
4 5 3 7 2 8 1 6 10 9
1 Hello Bob
1995 CERC
0
0
```

样例输出

```
BolHeol  b
C RCE
```

来源

Central Europe 1995



这其实就是一个移位密码算法题，只是多了个循环，密码学里面也指出过循环运算是没有效果的，所以题目估计也就考察了这一点。

https://blog.csdn.net/tigerisland45/article/details/85225299

这是一个密码编码计算题，通过置换计算密码。然而，直接通过置换计算进行模拟则容易造成TLE。置换计算有周期性，算出其循环周期，就可以使用模除来减少模拟次数。本题需要做k次置换，k值有可能很大。



```python
def move(st, t, a):
    for i in range(t):
        st = a[st]
    return st


# 计算周期，即加密多少次后导致的效果是相同的
def find_cir(a, n):
    ret = []    # 保存每个位置的周期，即循环节
    for i in range(n):
        x = a[i]
        cnt = 1
        while (x != i):
            x = a[x]
            cnt += 1
        ret.append(cnt)
    return ret


while (1):
    n = int(input())
    if (n == 0):
        break
    a = list(map(int, input().split()))
    for i in range(n):
        a[i] -= 1
    cir = find_cir(a, n)

    while (1):
        st = input().split(' ', 1)
        k = int(st[0])
        if (k == 0):
            break
        st = list(st[1])
        while (len(st) < n):
            st.append(' ')
        ans = [''] * n
        for i in range(n):
            # 取模省略了之前的多次不必要计算
            ans[move(i, k % cir[i], a)] = st[i]
        print(''.join(ans))
    print()

```




