# 02797: 最短前缀

http://cs101.openjudge.cn/practice/02797/

一个字符串的前缀是从该字符串的第一个字符起始的一个子串。例如 "carbon"的字串是: "c", "ca", "car", "carb", "carbo", 和 "carbon"。注意到这里我们不认为空串是字串, 但是每个非空串是它自身的字串. 我们现在希望能用前缀来缩略的表示单词。例如, "carbohydrate" 通常用"carb"来缩略表示. 现在给你一组单词, 要求你找到唯一标识每个单词的最短前缀
在下面的例子中，"carbohydrate" 能被缩略成"carboh", 但是不能被缩略成"carbo" (或其余更短的前缀) 因为已经有一个单词用"carbo"开始
一个精确匹配会覆盖一个前缀匹配，例如，前缀"car"精确匹配单词"car". 因此 "car" 是 "car"的缩略语是没有二义性的 , “car”不会被当成"carriage"或者任何在列表中以"car"开始的单词.

**输入**

输入包括至少2行，至多1000行. 每行包括一个以小写字母组成的单词，单词长度至少是1，至多是20.

**输出**

输出的行数与输入的行数相同。每行输出由相应行输入的单词开始，后面跟着一个空格接下来是相应单词的没有二义性的最短前缀标识符。

样例输入

```
carbohydrate
cart
carburetor
caramel
caribou
carbonic
cartilage
carbon
carriage
carton
car
carbonate
```

样例输出

```
carbohydrate carboh
cart cart
carburetor carbu
caramel cara
caribou cari
carbonic carboni
cartilage carti
carbon carbon
carriage carr
carton carto
car car
carbonate carbona
```

来源: 翻译自Rocky Mountain 2004



```python
words = []
while True:
    try:
        words.append(input())
    except EOFError:
        break
n = len(words)
sorted_words = sorted(words)
buffer = set()
pre_dict = dict()
for i, w in enumerate(sorted_words):
    for j in range(len(w)):
        pre = w[:j+1]
        if (pre in buffer):
            continue
        if i+1 < n and sorted_words[i+1].startswith(pre):
            buffer.add(pre)
        else:
            break
    pre_dict[w] = w[:j+1]
for w in words:
    print(w, pre_dict[w])
```



```python
# 蒋子轩
# 字典树
def insert(root, word):
    # 将单词插入字典树
    node = root
    for char in word:
        if char not in node:
            node[char] = {}  # 如果字符不存在，则在当前节点下创建一个新节点
        node = node[char]   # 移动到下一个节点
        node['count'] = node.get('count', 0) + 1  # 更新节点上的计数
def find_prefix(root, word):
    # 在字典树中为单词找到独特的最短前缀
    node = root
    prefix = ""
    for char in word:
        if node[char].get('count', 1) == 1:
            return prefix + char  # 如果该节点的计数为1，则返回当前前缀加上该字符
        prefix += char  # 否则，将字符添加到前缀中
        node = node[char]  # 继续遍历下一个字符
    return prefix
root = {}

words = []
while True:
    try:
        words.append(input())
    except EOFError:
        break
        
for word in words:
    insert(root, word)
for word in words:
    prefix = find_prefix(root, word)
    print(f"{word} {prefix}")
```


