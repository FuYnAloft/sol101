# 01002: 方便记忆的电话号码

implementation, hash table, http://cs101.openjudge.cn/practice/01002/

英文字母（除Q和Z外）和电话号码存在着对应关系，如下所示：

A,B,C -> 2

D,E,F -> 3

G,H,I -> 4

J,K,L -> 5

M,N,O -> 6

P,R,S -> 7

T,U,V -> 8

W,X,Y -> 9

标准的电话号码格式是xxx-xxxx，其中x表示0-9中的一个数字。有时为了方便记忆电话号码，我们会将电话号码的数字转变为英文字母，如把263-7422记成America。有时，我们还加上“-”作为分隔符，如把449-6753记成Hi-World。当然，我们未必要将所有的数字都转变为字母，比如474-6635可以记成iPhone-5。

总之，一个方便记忆的电话号码由数字和除Q、Z外的英文字母组成，并且可以在任意位置插入任意多的“-”符号。

现在 ，我们有一个列表，记录着许多方便记忆的电话号码。不同的方便记忆的电话号码可能对应相同的标准号码，你的任务就是找出它们。

**输入**

第一行是一个正整数n（n <= 100000），表示列表中的电话号码数。
其后n行，每行是一个方便记忆的电话号码，它由数字和除Q、Z外的英文字母、“-”符号组成，其中数字和字母的总数一定为7，字符串总长度不超过200。

**输出**

输出包括若干行，每行包括一个标准电话号码（xxx-xxxx）以及它重复出现的次数k（k >= 2），中间用空格分隔。输出的标准电话号码需按照升序排序。

如果没有重复出现的标准电话号码，则输出一行“No duplicates.”。

样例输入

```
12
4873279
ITS-EASY
888-4567
3-10-10-10
888-GLOP
TUT-GLOP
967-11-11
310-GINO
F101010
888-1200
-4-8-7-3-2-7-9-
487-3279
```

样例输出

```
310-1010 2
487-3279 4
888-4567 3 
```





```python
# 定义字母到数字的映射关系
letter_to_digit = {
    'A': '2', 'B': '2', 'C': '2',
    'D': '3', 'E': '3', 'F': '3',
    'G': '4', 'H': '4', 'I': '4',
    'J': '5', 'K': '5', 'L': '5',
    'M': '6', 'N': '6', 'O': '6',
    'P': '7', 'R': '7', 'S': '7',
    'T': '8', 'U': '8', 'V': '8',
    'W': '9', 'X': '9', 'Y': '9'
}

# 将方便记忆的电话号码转换为标准格式
def convert_to_standard(phone):
    digits = []
    for char in phone:
        if char.isdigit():  # 如果是数字，直接加入
            digits.append(char)
        elif char.isalpha():  # 如果是字母，根据映射转换为数字
            digits.append(letter_to_digit[char.upper()])
    # 标准格式化为 xxx-xxxx
    return f"{digits[0]}{digits[1]}{digits[2]}-{digits[3]}{digits[4]}{digits[5]}{digits[6]}"

n = int(input())  # 输入电话号码的数量
phone_count = {}  # 记录每个标准电话号码出现的次数

for _ in range(n):
    phone = input().strip()  # 读取一个方便记忆的电话号码
    standard_phone = convert_to_standard(phone)  # 转换为标准格式
    phone_count[standard_phone] = phone_count.get(standard_phone, 0) + 1  # 统计次数

# 找出重复的标准电话号码
duplicates = {phone: count for phone, count in phone_count.items() if count >= 2}

if duplicates:
    # 按照标准电话号码升序排序并输出
    for phone in sorted(duplicates.keys()):
        print(f"{phone} {duplicates[phone]}")
else:
    print("No duplicates.")

```


