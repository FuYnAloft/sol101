# M04147: 汉诺塔问题(Tower of Hanoi)

recursion, stack, http://cs101.openjudge.cn/pctbook/M04147

一、汉诺塔问题

 有三根杆子A，B，C。A杆上有N个(N>1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆： 每次只能移动一个圆盘； 大盘不能叠在小盘上面。 提示：可将圆盘临时置于B杆，也可将从A杆移出的圆盘重新移回A杆，但都必须遵循上述两条规则。

 问：如何移？最少要移动多少次？

汉诺塔示意图如下：

![img](https://raw.githubusercontent.com/GMyhf/img/main/img/HrgWMsoRAcPJ9Ga-20230915145511196.jpg)

三个盘的移动：

![img](https://raw.githubusercontent.com/GMyhf/img/main/img/lrje6OLwCZi7oGx-20230915145555183.gif)



二、故事由来

  法国数学家爱德华·卢卡斯曾编写过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根宝石针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的64片金片，这就是所谓的汉诺塔。不论白天黑夜，总有一个僧侣在按照下面的法则移动这些金片：一次只移动一片，不管在哪根针上，小片必须在大片上面。僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。

  不管这个传说的可信度有多大，如果考虑一下把64片金片，由一根针上移到另一根针上，并且始终保持上小下大的顺序。这需要多少次移动呢?这里需要递归的方法。假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1。此后不难证明f(n)=2^n-1。n=64时， 假如每秒钟一次，共需多长时间呢？一个平年365天有31536000 秒，闰年366天有31622400秒，平均每年31556952秒，计算一下： 18446744073709551615秒 这表明移完这些金片需要5845.54亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，不说太阳系和银河系，至少地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。

三、解法

 解法的基本思想是递归。假设有A、B、C三个塔，A塔有N块盘，目标是把这些盘全部移到C塔。那么先把A塔顶部的N-1块盘移动到B塔，再把A塔剩下的大盘移到C，最后把B塔的N-1块盘移到C。 每次移动多于一块盘时，则再次使用上述算法来移动。

**输入**

输入为一个整数后面跟三个单字符字符串。
整数为盘子的数目，后三个字符表示三个杆子的编号。

**输出**

输出每一步移动盘子的记录。一次移动一行。
每次移动的记录为例如3:a->b 的形式，即把编号为3的盘子从a杆移至b杆。
我们约定圆盘从小到大编号为1, 2, ...n。即最上面那个最小的圆盘编号为1，最下面最大的圆盘编号为n。

样例输入

```
3 a b c
```

样例输出

```
1:a->c
2:a->b
1:c->b
3:a->c
1:b->a
2:b->c
1:a->c
```

提示：可参考如下网址：
https://www.mathsisfun.com/games/towerofhanoi.html
http://blog.csdn.net/geekwangminli/article/details/7981570
http://www.cnblogs.com/yanlingyin/archive/2011/11/14/2247594.html

来源：重庆科技学院 WJQ



```python
# https://blog.csdn.net/geekwangminli/article/details/7981570

# 将编号为numdisk的盘子从init杆移至desti杆 
def moveOne(numDisk : int, init : str, desti : str):
    print("{}:{}->{}".format(numDisk, init, desti))

#将numDisks个盘子从init杆借助temp杆移至desti杆
def move(numDisks : int, init : str, temp : str, desti : str):
    if numDisks == 1:
        moveOne(1, init, desti)
    else: 
        # 首先将上面的（numDisk-1）个盘子从init杆借助desti杆移至temp杆
        move(numDisks-1, init, desti, temp) 
        
        # 然后将编号为numDisks的盘子从init杆移至desti杆
        moveOne(numDisks, init, desti)
        
        # 最后将上面的（numDisks-1）个盘子从temp杆借助init杆移至desti杆 
        move(numDisks-1, temp, init, desti)

n, a, b, c = input().split()
move(int(n), a, b, c)
```



```python
def hanoi_iterative(n, a, b, c):
    stack = [(n, a, b, c, False)]
    while stack:
        n, s, aux, t, left_done = stack.pop()
        if n == 1:
            yield f"1:{s}->{t}"
        elif not left_done:
            stack.append((n, s, aux, t, True))      # 标记“左子任务”完成后再回来
            stack.append((n - 1, s, t, aux, False)) # 左子任务
        else:
            yield f"{n}:{s}->{t}"                   # 中间动作
            stack.append((n - 1, aux, s, t, False)) # 右子任务

if __name__ == "__main__":
    n, a, b, c = input().split()
    n = int(n)
    print("\n".join(hanoi_iterative(n, a, b, c)))
```


> “左子任务”，其实是借助树形递归结构来形象地理解汉诺塔递归过程的。  
> 
> **一、递归函数树结构**
> 
> 递归 `hanoi(n, a, b, c)` 的执行逻辑是：
> 
> ```python
> if n == 1:
>     print(f"1:{a}->{c}")
> else:
>     hanoi(n-1, a, c, b)   # 第一步：把上面的 n-1 个盘从 a 移到 b
>     print(f"{n}:{a}->{c}") # 第二步：把最大的盘从 a 移到 c
>     hanoi(n-1, b, a, c)   # 第三步：再把那 n-1 个盘从 b 移到 c
> ```
> 
> 从“函数调用树”的角度看，这其实是个**二叉递归结构**：
> 
> ```
>                     hanoi(3, A, B, C)
>                    /                \
>       hanoi(2, A, C, B)           hanoi(2, B, A, C)
> ```
> 
> 每个节点：
> 
> - 左边调用是 “把上面 n-1 个盘移到辅助柱”；
>     
> - 中间是 “把最大的盘移到目标柱”；
>     
> - 右边调用是 “再把那 n-1 个盘移到目标柱”。
>     
> 
> 因此我们常把：
> 
> - `hanoi(n-1, a, c, b)` 称为 **左子任务**；
>     
> - `hanoi(n-1, b, a, c)` 称为 **右子任务**。
>     
> 
> ---
> 
> 二、在栈模拟中，“左子任务”指的是什么？
> 
> 在这段代码里：
> 
> ```python
> elif not visited:
>     stack.append((num, s, aux, t, True))        # 当前任务(标记左子任务完成后回来)
>     stack.append((num - 1, s, t, aux, False))   # 左子任务：把 n-1 从 s -> aux
> ```
> 
> 含义如下：
> 


> |行|含义|对应递归调用|
> |---|---|---|
> |`stack.append((num, s, aux, t, True))`|先把当前任务压回栈，表示等“左子任务”完成后再回来执行|暂停当前 hanoi(n)|
> |`stack.append((num - 1, s, t, aux, False))`|压入“左子任务”——把上面 n-1 个盘从 s 移到 aux|调用 hanoi(n-1, a, c, b)|
> 
> ---
> 
> **三、再来看完整的三个阶段**
> 
> 对于 `hanoi(n, a, b, c)`，对应的三个阶段是：
> 


> |阶段|名称|动作|在模拟代码中的表现|
> |---|---|---|---|
> |①|左子任务|把 n−1 个盘从 a → b|压入 `(n-1, s, t, aux, False)`|
> |②|中间动作|把第 n 个盘从 a → c|`result.append(f"{n}:{s}->{t}")`|
> |③|右子任务|把 n−1 个盘从 b → c|压入 `(n-1, aux, s, t, False)`|
> 
> ---
> 
> **四、直观类比**
> 
> 想象有三步要完成：
> 
> ```
> 1️⃣ 先干左边的事
> 2️⃣ 再干自己的事
> 3️⃣ 最后干右边的事
> ```
> 
> 递归自然会自动“记住回来继续干”，  
> 而我们手动模拟时，就要自己用栈来“记住回来继续干”，  
> 那就是通过这个 `visited` 或 `left_done` 标志位实现的。
> 
> ---
> 
> **五、小结**
> 


> |概念|含义|
> |---|---|
> |左子任务|`hanoi(n-1, a, c, b)`，先把上面的盘移到辅助柱|
> |中间动作|移动最大盘 `n:{a}->{c}`|
> |右子任务|`hanoi(n-1, b, a, c)`，再把那些盘从辅助柱移到目标柱|
> |visited / left_done|表示左子任务是否已经执行完成，是否可以继续中间动作和右子任务|
> 
> 


