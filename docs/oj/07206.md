# T07206: æˆ‘æ˜¯æœ€å¿«çš„é©¬

bfs, http://cs101.openjudge.cn/pctbook/T07206/

æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œåœ¨ä¸­å›½è±¡æ£‹ä¸­ï¼Œé©¬æ˜¯èµ°æ—¥å­—æ­¥çš„ã€‚ç°ç»™å®šé©¬çš„èµ·å§‹åæ ‡ä¸ç»ˆç‚¹åæ ‡ï¼Œæ±‚å‡ºé©¬æœ€å¿«èƒ½åˆ°è¾¾çš„è·¯çº¿ã€‚å¦‚æœæœ‰å¤šæ¡è·¯çº¿éƒ½æ˜¯æ­¥æ•°æœ€å°‘çš„ï¼Œåˆ™è¾“å‡ºè·¯çº¿çš„æ•°ç›®
æ³¨æ„ï¼Œæ­¤æ—¶æ£‹ç›˜ä¸Šå¯èƒ½ä¼šæœ‰ä¸€äº›å…¶å®ƒçš„æ£‹å­ï¼Œè¿™äº›æ£‹å­æ˜¯ä¼šæ†‹é©¬è„šçš„ï¼Œæ³¨æ„ï¼

**è¾“å…¥**

å‰ä¸¤è¡Œä¸ºèµ·ç‚¹åæ ‡ä¸ç»ˆç‚¹åæ ‡ï¼Œç¬¬ä¸‰è¡Œä¸ºä¸€ä¸ªæ•°å­—Mï¼Œä¹‹åçš„Mè¡Œä¸ºæ£‹ç›˜ä¸Šå…¶å®ƒæ£‹å­çš„åæ ‡(M<32,åæ ‡è¡Œåˆ—å€¼<=10)

**è¾“å‡º**

å¦‚æœæœ€å¿«è·¯çº¿å”¯ä¸€ï¼Œåˆ™è¾“å‡ºè·¯çº¿ã€‚å¦åˆ™åªè¾“å‡ºä¸€ä¸ªæ•°å­—ï¼Œä¸ºæœ€å¿«è·¯çº¿çš„æ•°ç›®N

æ ·ä¾‹è¾“å…¥

```
0 0
2 4
1
1 1
```

æ ·ä¾‹è¾“å‡º

```
(0,0)-(1,2)-(2,4)
```







<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/b4c01a0068041117b4a1c0fe66cb4e04.png" alt="b4c01a0068041117b4a1c0fe66cb4e04" style="zoom:50%;" />



 **ã€Šå›¾ + BFS + å›æº¯ï¼ˆPath Reconstructionï¼‰ã€‹æ ‡å‡†ç®—æ³•è®²ä¹‰ç‰ˆ**â€”â€”
 è¿™æ˜¯é«˜æ ¡ç®—æ³•è¯¾/ç«èµ›æ•™ç¨‹é‡Œå¸¸ç”¨çš„è§„èŒƒå†™æ³•ï¼ŒåŒ…æ‹¬ï¼š

- é—®é¢˜å»ºæ¨¡
- å›¾è¡¨ç¤º
- BFS æ±‚æœ€çŸ­è·¯
- è®°å½•æœ€çŸ­è·¯å¾„æ¡æ•°
- å›æº¯æ¢å¤å”¯ä¸€è·¯å¾„

æ—¢å¯ä»¥ä½œä¸ºæ•™æï¼Œä¹Ÿå¯ä»¥ç›´æ¥è®²ç»™å­¦ç”Ÿï¼Œéå¸¸æ¸…æ™°ã€æ ‡å‡†åŒ–ã€‚

------

ğŸ“˜ **ç®—æ³•è®²ä¹‰ï¼šå›¾ + BFS + å›æº¯æ„é€ æœ€çŸ­è·¯å¾„**

1. **é—®é¢˜æ¨¡å‹ï¼ˆGraph Modelï¼‰**

è±¡æ£‹é©¬æ‰€åœ¨çš„æ£‹ç›˜æ˜¯ä¸€ä¸ª **11Ã—11 çš„ç½‘æ ¼å›¾**ï¼Œæ¯ä¸ªæ ¼å­å¯¹åº”å›¾ä¸­çš„ä¸€ä¸ªã€ŒèŠ‚ç‚¹ã€ã€‚

é©¬çš„ç§»åŠ¨éµå¾ªè±¡æ£‹è§„åˆ™ï¼ŒåŒ…å« **è¹©é©¬è„š**ï¼Œå› æ­¤æ¯ä¸ªèŠ‚ç‚¹åˆ°å‘¨å›´èŠ‚ç‚¹çš„è¾¹æ˜¯å¦å­˜åœ¨è¦æŒ‰è§„åˆ™åŠ¨æ€åˆ¤æ–­ï¼š

- è‹¥é©¬è„šä½ç½®è¢«éšœç¢å æ®ï¼Œåˆ™è¯¥æ–¹å‘æ— æ³•ç§»åŠ¨ï¼›
- è‹¥è½ç‚¹æ˜¯éšœç¢ï¼Œä¹Ÿæ— æ³•ç§»åŠ¨ï¼›
- æ¯æ¬¡ç§»åŠ¨çš„ä»£ä»·å‡ä¸º 1ï¼ˆæ— æƒå›¾ï¼‰ã€‚

å› æ­¤ï¼Œè¯¥é—®é¢˜æ˜¯ä¸€ä¸ª **æ— æƒå›¾æœ€çŸ­è·¯å¾„ + è·¯å¾„æ•°é‡ç»Ÿè®¡ + å”¯ä¸€è·¯å¾„æ¢å¤** çš„ç»¼åˆé—®é¢˜ã€‚

------

**2. å›¾çš„é‚»æ¥è§„åˆ™ï¼ˆImplicit Graphï¼‰**

æˆ‘ä»¬ä¸éœ€è¦æå‰å»ºå¥½æ‰€æœ‰è¾¹ï¼Œè€Œæ˜¯ **BFS æ—¶åŠ¨æ€åˆ¤æ–­å¯ç§»åŠ¨æ–¹å‘**ã€‚

æ¯ä¸ªæ–¹å‘åŒ…å«ä¸¤ä¸ªåæ ‡ï¼š

- `(dx, dy)`: é©¬çš„æœ€ç»ˆè½ç‚¹
- `(bx, by)`: é©¬è…¿ä½ç½®ï¼Œç”¨äºåˆ¤æ–­è¹©é©¬è„š

------

**3. BFSï¼šæ±‚æœ€çŸ­è·¯ + æœ€çŸ­è·¯å¾„æ¡æ•°**

å¯¹æ— æƒå›¾ï¼Œæœ€çŸ­è·¯å¯ä»¥ç”¨ BFS æ±‚ã€‚

æˆ‘ä»¬ç»´æŠ¤ä¸‰ä¸ªç»“æ„ï¼š

**3.1 `dist[x][y]`**

è®°å½•èµ·ç‚¹åˆ°æ¯ä¸ªç‚¹çš„ **æœ€çŸ­æ­¥æ•°**
 é»˜è®¤å€¼ä¸º `INF`ã€‚

**3.2 `ways[x][y]`**

è®°å½•åˆ°è¾¾ `(x, y)` çš„ **æœ€çŸ­è·¯å¾„æ¡æ•°**ã€‚

å½“è®¿é—®ä¸€ä¸ªæ–°èŠ‚ç‚¹ï¼š

- ç¬¬ä¸€æ¬¡åˆ°è¾¾ï¼š
  `dist[nx][ny] = dist[x][y] + 1`
  `ways[nx][ny] = ways[x][y]`
- è‹¥å†æ¬¡é‡åˆ°å¦ä¸€æ¡åŒæ ·é•¿åº¦çš„è·¯å¾„ï¼š
  `ways[nx][ny] += ways[x][y]`

**3.3 `prev[x][y]`**

åªåœ¨ **å”¯ä¸€è·¯å¾„** çš„æƒ…å†µä¸‹è®°å½•è·¯å¾„çš„å‰é©±ã€‚

- åˆæ¬¡è®¿é—®ä¸” `ways[cur]==1` â†’ å¯ä»¥è®°å‰é©±
- è‹¥ä¸€ä¸ªèŠ‚ç‚¹å‡ºç°å¤šæ¡æœ€çŸ­è·¯å¾„ â†’ ç«‹å³å°† `prev[x][y] = None`ï¼ˆè¯´æ˜ä¸å†å”¯ä¸€ï¼‰

è¿™æ˜¯ä¸€ä¸ªéå¸¸ç»å…¸çš„æŠ€å·§ï¼š

> BFS è´Ÿè´£â€œæ˜¯å¦å”¯ä¸€â€åˆ¤æ–­ï¼›
> è‹¥å”¯ä¸€æ‰è®°å½•å‰é©±ï¼Œå¦åˆ™å–æ¶ˆå‰é©±ã€‚

è¿™æ ·æ—¢é«˜æ•ˆåˆä¸ä¸¢ä¿¡æ¯ã€‚

------

**4. å›æº¯æ¢å¤å”¯ä¸€è·¯å¾„ï¼ˆPath Reconstructionï¼‰**

è‹¥ç»ˆç‚¹ `(ex, ey)` æ»¡è¶³ï¼š

```
ways[ex][ey] == 1
```

è¯´æ˜æœ€çŸ­è·¯å¾„å”¯ä¸€ï¼Œå¯ä»¥ä» `prev[][]` ä¸­æ²¿ç€å‰é©±é“¾é€†å‘å›æº¯ï¼š

```
end â†’ ... â†’ start
```

ç„¶ååè½¬å³å¯å¾—åˆ°ï¼š

```
start â†’ ... â†’ end
```

è‹¥ `ways > 1`ï¼Œé¢˜ç›®è¦æ±‚åªè¾“å‡ºæ¡æ•°ï¼Œä¸æ¢å¤è·¯å¾„ã€‚

------

**â­ å®Œæ•´â€œè®²ä¹‰ç‰ˆâ€ä»£ç ï¼ˆç»“æ„æœ€è§„èŒƒã€æœ€é€‚åˆæ•™å­¦ï¼‰**

```python
def solve():
    from collections import deque

    # ---------- è¾“å…¥ ----------
    sx, sy = map(int, input().split())
    ex, ey = map(int, input().split())
    M = int(input())

    N = 11
    obs = set()
    for _ in range(M):
        r, c = map(int, input().split())
        obs.add((r, c))

    # ---------- é©¬çš„å›¾é‚»æ¥è§„åˆ™ï¼š8 ä¸ªæ–¹å‘ + è¹©é©¬è…¿ ----------
    moves = [
        (2,1,1,0), (2,-1,1,0),
        (-2,1,-1,0), (-2,-1,-1,0),
        (1,2,0,1), (-1,2,0,1),
        (1,-2,0,-1), (-1,-2,0,-1)
    ]

    # ---------- BFS æ ¸å¿ƒ ----------
    start = (sx,sy)
    end = (ex,ey)
    dist = {start: 0}   # æœ€çŸ­è·ç¦»
    ways = {start: 1}     # æœ€çŸ­è·¯å¾„æ•°é‡
    prev = {start: None}  # å”¯ä¸€è·¯å¾„çš„å‰é©±

    q = deque([start])

    while q:
        x, y = q.popleft()
        d = dist[(x, y)]

        for dx, dy, bx, by in moves:
            # 1. åˆ¤æ–­è¹©é©¬è…¿æ˜¯å¦è¢«éšœç¢é˜»æŒ¡
            legx, legy = x + bx, y + by
            if 0 <= legx < N and 0 <= legy < N and (legx, legy) in obs:
                continue

            # 2. åˆ¤æ–­è½ç‚¹åˆæ³•
            nx, ny = x + dx, y + dy
            if not (0 <= nx < N and 0 <= ny < N):
                continue
            if (nx, ny) in obs:
                continue

            new_pos = (nx, ny)
            nd = d + 1

            # 3. ç¬¬ä¸€æ¬¡åˆ°è¾¾è¯¥èŠ‚ç‚¹ï¼šæ›´æ–°æœ€çŸ­è·¯ã€è·¯å¾„æ•°é‡ã€å‰é©±
            if new_pos not in dist:
                dist[new_pos] = nd
                ways[new_pos] = ways[(x, y)]

                # è‹¥å‰é©±å”¯ä¸€è·¯å¾„æ‰è®°å½•ï¼Œä¹‹åè‹¥å‡ºç°å¤šè·¯å¾„ä¼šè¢«å–æ¶ˆ
                prev[new_pos] = (x, y) if ways[(x, y)] == 1 else None

                q.append(new_pos)

            # 4. å‘ç°å¦ä¸€æ¡åŒé•¿åº¦çš„è·¯å¾„ï¼šç´¯åŠ è·¯å¾„æ•°é‡
            elif nd == dist[new_pos]:
                ways[new_pos] += ways[(x, y)]
                prev[new_pos] = None  # ä¸å†å”¯ä¸€

    # ---------- è¾“å‡º ----------
    # ä¸å¯è¾¾
    if end not in dist:
        print("æ— è§£")
        return

    # å¤šæ¡è·¯å¾„ï¼šåªè¾“å‡ºæ•°ç›®
    if ways[end] > 1:
        print(ways[end])
        return

    # å”¯ä¸€è·¯å¾„ï¼šå›æº¯é‡å»ºè·¯å¾„
    path = []
    cur = end
    while cur is not None:
        path.append(cur)
        cur = prev[cur]
    path.reverse()

    print("-".join(f"({x},{y})" for x, y in path))


solve()
```

------

ğŸ“ æ•™å­¦é‡ç‚¹æ€»ç»“

**1. æœ¬é¢˜æ˜¯å…¸å‹çš„å›¾æœ€çŸ­è·¯å¾„é—®é¢˜ï¼šæ— æƒå›¾ â†’ BFS æœ€çŸ­è·¯**

**2. é¢å¤–ç»Ÿè®¡ã€Œæœ€çŸ­è·¯å¾„æ•°é‡ã€ï¼šways æ•°ç»„**

**3. åªæœ‰åœ¨è·¯å¾„å”¯ä¸€æ—¶æ‰è®°å½• prev æ‰èƒ½å›æº¯**

**4. å›æº¯æ„é€ è·¯å¾„ï¼šä»ç»ˆç‚¹æ²¿ prev ä¸€ç›´è¿½åˆ°èµ·ç‚¹**





```python
def solve():
    import sys
    from collections import deque
    start_r, start_c = map(int, input().split())
    end_r, end_c = map(int, input().split())
    M = int(input())
    obstacles = set()
    for _ in range(M):
        r, c = map(int, input().split())
        obstacles.add((r, c))

    # æ£‹ç›˜åæ ‡èŒƒå›´
    MIN, MAX = 0, 10

    # é©¬çš„èµ°æ³•ï¼šæ¯ä¸ªå…ƒç»„ä¸º(dx, dy, (block_dx, block_dy))
    moves = [
        (2, 1, (1, 0)), (2, -1, (1, 0)),
        (-2, 1, (-1, 0)), (-2, -1, (-1, 0)),
        (1, 2, (0, 1)), (-1, 2, (0, 1)),
        (1, -2, (0, -1)), (-1, -2, (0, -1))
    ]

    def in_bounds(pos):
        r, c = pos
        return MIN <= r <= MAX and MIN <= c <= MAX

    start = (start_r, start_c)
    end = (end_r, end_c)

    # BFSï¼šdistè®°å½•æœ€çŸ­æ­¥æ•°ï¼Œwaysè®°å½•æœ€çŸ­è·¯å¾„æ•°ï¼Œprevåœ¨å”¯ä¸€è·¯å¾„æ—¶è®°å½•å‰é©±ä¾¿äºé‡æ„è·¯å¾„
    dist, ways, prev = {}, {}, {}
    dist[start] = 0
    ways[start] = 1
    prev[start] = None
    q = deque([start])

    while q:
        cur = q.popleft()
        r, c = cur
        for dx, dy, (br, bc) in moves:
            # è®¡ç®—â€œè¹©é©¬è…¿â€æ‰€åœ¨ä½ç½®
            block = (r + br, c + bc)
            # å¦‚æœè¯¥ä½ç½®åœ¨æ£‹ç›˜ä¸Šä¸”è¢«å…¶å®ƒæ£‹å­å æ®ï¼Œåˆ™è¯¥æ–¹å‘èµ°æ³•è¢«é˜»æŒ¡
            if in_bounds(block) and block in obstacles:
                continue
            newPos = (r + dx, c + dy)
            if not in_bounds(newPos) or newPos in obstacles:
                continue
            nd = dist[cur] + 1
            if newPos not in dist:
                dist[newPos] = nd
                ways[newPos] = ways[cur]
                # è‹¥å½“å‰ç‚¹åªæœ‰ä¸€æ¡è·¯å¾„ï¼Œåˆ™è®°å½•å‰é©±ï¼›å¦‚æœä¸å”¯ä¸€ï¼Œåˆ™è®¾ä¸ºNone
                prev[newPos] = cur if ways[cur] == 1 else None
                q.append(newPos)
            elif nd == dist[newPos]:
                ways[newPos] += ways[cur]
                # å‰é©±ä¸å†å”¯ä¸€
                prev[newPos] = None

    # å¦‚æœç›®æ ‡ä¸å¯è¾¾ï¼Œè¾“å‡º"æ— è§£"
    if end not in dist:
        print("æ— è§£")
        return

    # å¦‚æœåªæœ‰å”¯ä¸€ä¸€æ¡æœ€çŸ­è·¯å¾„ï¼Œåˆ™é‡æ„è·¯å¾„è¾“å‡ºæ ¼å¼ "(r,c)-(r,c)-..."
    if ways[end] == 1:
        path = []
        cur = end
        while cur is not None:
            path.append(cur)
            cur = prev[cur]
        path.reverse()
        route_str = "-".join("({},{})".format(r, c) for r, c in path)
        print(route_str)
    else:
        # å¤šæ¡æœ€çŸ­è·¯å¾„åˆ™è¾“å‡ºè·¯å¾„æ•°ç›®
        print(str(ways[end]))


if __name__ == '__main__':
    solve()

"""
0 0
2 2
0

16
"""
```

å¦å¤–ï¼Œé¢˜é¢â€œåæ ‡è¡Œåˆ—å€¼<=10â€ æ²¡æœ‰è¯´æ˜æ˜¯å¦å¯ä»¥åˆ°-10ã€‚å¦‚æœ MIN, MAX = -10, 10èŒƒå›´ï¼Œä¸Šä¾‹è¾“å…¥æƒ…å†µä¸‹ç»“æœæ˜¯54ã€‚


