# E07743: 计算矩阵边缘元素之和

implementation, http://cs101.openjudge.cn/pctbook/E07743/

输入一个整数矩阵，计算位于矩阵边缘的元素之和。所谓矩阵边缘的元素，就是第一行和最后一行的元素以及第一列和最后一列的元素。

**输入**

第一行分别为矩阵的行数m和列数n（m < 100，n < 100），两者之间以一个空格分开。
接下来输入的m行数据中，每行包含n个整数，整数之间以一个空格分开。

**输出**

输出对应矩阵的边缘元素和

样例输入

```
3 3
3 4 1
3 7 1
2 0 1
```

样例输出

```
15
```



模拟实现

```python
import sys

data = iter(sys.stdin.read().strip().split())
try:
    m = int(next(data))
    n = int(next(data))
except StopIteration:
    # 输入不足
    print(0)
    sys.exit()

# 读取矩阵（假设输入格式正确，恰好有 m*n 个整数）
matrix = [[int(next(data)) for _ in range(n)] for _ in range(m)]

total = 0
if m == 0 or n == 0:
    total = 0
elif m == 1:
    # 只有一行，边缘就是这一整行
    total = sum(matrix[0])
elif n == 1:
    # 只有一列，边缘就是这一整列
    total = sum(row[0] for row in matrix)
else:
    # 普通情况：首行 + 末行 + 中间行的首列和末列
    total += sum(matrix[0])      # 第一行
    total += sum(matrix[-1])     # 最后一行
    for i in range(1, m-1):
        total += matrix[i][0] + matrix[i][-1]

print(total)
```



模拟“沿着矩阵边缘走一圈”的过程：

- 初始位置在左上角 `(0,0)`；按照 **右 → 下 → 左 → 上** 的方向依次行走；
- 每次走到边界或已经访问过的位置，就转向；最终走完一圈，累加经过的元素。

这样就像“贴着边走”，不会重复。下面是实现：

```python
import sys

data = iter(sys.stdin.read().strip().split())
m = int(next(data))
n = int(next(data))
matrix = [[int(next(data)) for _ in range(n)] for _ in range(m)]

# 方向：右、下、左、上
dirs = [(0,1),(1,0),(0,-1),(-1,0)]

visited = [[False]*n for _ in range(m)]
total = 0

# 从 (0,0) 出发
x, y = 0, 0
d = 0  # 当前方向索引
for _ in range(2*m + 2*n - 4 if m>1 and n>1 else m*n):
    total += matrix[x][y]
    visited[x][y] = True

    # 尝试向当前方向走
    nx, ny = x + dirs[d][0], y + dirs[d][1]
    # 如果越界或已经访问，转向
    if not (0 <= nx < m and 0 <= ny < n and not visited[nx][ny]):
        d = (d + 1) % 4
        nx, ny = x + dirs[d][0], y + dirs[d][1]
    x, y = nx, ny

print(total)

```

来拆开解释一下这个循环条件，`2*m + 2*n - 4 if m > 1 and n > 1 else m*n`：

矩阵边缘元素的数量，其实就是 **一圈**：

- **正常情况（m > 1 且 n > 1）：**
  - 上边一行：`n` 个
  - 下边一行：`n` 个
  - 左边一列（除去角落）：`m - 2` 个
  - 右边一列（除去角落）：`m - 2` 个
  - 合计：`n + n + (m-2) + (m-2) = 2*m + 2*n - 4`
- **特殊情况：**
  - 如果矩阵只有 **一行 (m=1)**，边缘就是这一行，共 `n` 个元素。
  - 如果矩阵只有 **一列 (n=1)**，边缘就是这一列，共 `m` 个元素。
  - 所以可以统一写成：`m*n`（因为单行或单列时，边缘 = 全部元素）。




