# T20052: 最大点数（同2048规则）

dfs, matrices, http://cs101.openjudge.cn/practice/20052/

2048是一款不用念诗能够实现时间跳跃的小游戏（参考https://2048game.com），只需玩5分钟，就可以跳到两小时后的世界。J同学在进行了上百次时间穿越后，得到灵感设计了一款新游戏，规则如下。
保持原2048规则（重力作用）中移动方块和增加点数的方法不变，棋盘从4*4变成m*n型，开始时棋盘上即摆放了一些不同点数的方块，但每次移动后不会生成新的方块。在有限的操作次数（往上/下/左/右方向上移动一次记为一次操作）内，得到更高点数（即所有方块中点数最高者）。示例图如下：

![img](http://media.openjudge.cn/images/upload/1576723667.png)



**输入**

第一行：整数m与n（2 <= m, n <= 10）,最大操作次数p（1 <= p <= 6）。空格分隔。
之后m行：空格分隔的n个整数，代表每一格上方块的点数（2, 4, 8, 16, ..., 1024）。若为0，则表示此格没有方块。这m行输入保证不全为0（即不会输入空棋盘）。

**输出**

一个整数，代表p次操作内能得到的最高点数。

样例输入

```
Sample1 Input:
4 4 2
2 4 512 16
2 128 16 16
2 8 256 0
2 512 256 2

Sample1 Output:
1024

解释：第一步，向下移动，变成
0 4 0 0
0 128 512 0
4 8 16 32
4 512 512 2
第二步，向左移动，将第4行两个512拼合得到1024。
```

样例输出

```
Sample2 Input:
2 3 6
2 4 4
32 16 8

Sample2 Output:
64

解释：第一步，向右移动，第二步，向下移动，第三步，向左移动，第四步，向左移动。后两步无论怎样移动最大值都是64。

Sample3 Input:
4 3 5
32 256 128
256 128 64
32 64 128
256 128 256

Sample3 Output:
256

解释：此局面如何移动都不会变，故最大值为256。
```

提示

注：请注意移动方向不同会导致方块的合并方向不同。如对于4 4 4 0，向左移动时得到8 4 0 0，而向右移动时得到0 0 4 8。
同时，单次操作内同一行（列）中不允许连续合并，如32 16 8 8向左移动得到32 16 16 0，而非直接得到64 0 0 0，又如2 2 2 2经一次左移后得到4 4 0 0而非8 0 0 0。

来源

cs101-2019 胡康德龙



```python
# pylint: skip-file
def move_left(board):
    m, n = len(board), len(board[0])
    new_board = []
    for row in board:
        # 压缩：去除0，保留非0数值
        filtered = [x for x in row if x != 0]
        merged = []
        skip = False
        i = 0
        while i < len(filtered):
            if i + 1 < len(filtered) and filtered[i] == filtered[i + 1]:
                # 合并，注意每行内只允许合并一次
                merged.append(filtered[i] * 2)
                i += 2
            else:
                merged.append(filtered[i])
                i += 1
        # 补0到尾部
        merged += [0] * (n - len(merged))
        new_board.append(merged)
    return new_board


def reverse_board(board):
    # 将每一行反转（用于模拟向右移动）
    return [row[::-1] for row in board]


def transpose(board):
    return [list(x) for x in zip(*board)]


def move_right(board):
    # 向右移动：先反转->左移->再反转
    reversed_board = reverse_board(board)
    moved = move_left(reversed_board)
    return reverse_board(moved)


def move_up(board):
    # 向上移动：转置->左移->再转置
    trans = transpose(board)
    moved = move_left(trans)
    return transpose(moved)


def move_down(board):
    # 向下移动：转置->右移->再转置
    trans = transpose(board)
    moved = move_right(trans)
    return transpose(moved)


def get_max_tile(board):
    return max(max(row) for row in board)


def dfs(board, moves_left):
    global answer
    current_max = get_max_tile(board)
    answer = max(answer, current_max)
    if moves_left == 0:
        return

    # 对四个方向进行移动
    for move_func in [move_left, move_right, move_up, move_down]:
        new_board = move_func(board)
        # 若该操作没有产生变化，则无需再搜索
        if new_board == board:
            continue
        dfs(new_board, moves_left - 1)


if __name__ == '__main__':
    m, n, p = map(int, input().split())
    board = []
    for i in range(m):
        row = list(map(int, input().split()))
        board.append(row)

    answer = 0
    dfs(board, p)
    print(answer)


```

> `transpose`、`move_up` 和 `move_down` 是为了方便操作二维列表（棋盘）进行的矩阵变换。
>
> ---
>
> **1. `transpose`（矩阵转置）**
>
> **作用**：交换行和列，将 **m×n** 的棋盘转换成 **n×m**。
>
> ```python
> def transpose(board):
>     return [list(x) for x in zip(*board)]
> ```
>
> **示例**
>
> ```python
> board = [
>     [2, 4, 8],
>     [16, 32, 64]
> ]
> 
> new_board = transpose(board)
> ```
>
> **原始棋盘**：
>
> ```
> 2   4   8
> 16 32  64
> ```
>
> **转置后**：
>
> ```
> 2  16
> 4  32
> 8  64
> ```
>
> **原因**：
>
> - `zip(*board)` 取出 `board` 每一列，返回的是元组 `(2,16)`, `(4,32)`, `(8,64)`
>
> - `list(x) for x in ...` 把元组转成列表，得到：
>
>   ```python
>   [[2, 16],
>    [4, 32],
>    [8, 64]]
>   ```
>
> ---
>
> **2. `move_up`（向上移动）**
>
> **逻辑**：
>
> 1. **转置**（`transpose(board)`） → 让列变成行
> 2. **左移**（`move_left(transposed_board)`） → 模拟向左移动
> 3. **再转置回来**（`transpose(moved_board)`） → 还原列
>
> ```python
> def move_up(board):
>     transposed = transpose(board)  # 先转置，让列变成行
>     moved = move_left(transposed)  # 在横向执行 move_left
>     return transpose(moved)  # 还原回来
> ```
>
> **3. `move_down`（向下移动）**
>
> **逻辑**：
>
> 1. **转置**（`transpose(board)`） → 让列变成行
> 2. **右移**（`move_right(transposed_board)`） → 模拟向右移动
> 3. **再转置回来**（`transpose(moved_board)`） → 还原列
>
> ```python
> def move_down(board):
>     transposed = transpose(board)  # 先转置，让列变成行
>     moved = move_right(transposed)  # 在横向执行 move_right
>     return transpose(moved)  # 还原回来
> ```
>
> **总结**
>
> - `transpose(board)`: 行列互换（用于把列变成行处理）
> - `move_up`: 先转置 → `move_left` → 转置回来
> - `move_down`: 先转置 → `move_right` → 转置回来
>
> 这样就能用 **`move_left` 和 `move_right`** 统一处理所有方向！




