# 25353: æ’é˜Ÿ

Greedy, http://cs101.openjudge.cn/practice/25353/

æœ‰ N ååŒå­¦ä»å·¦åˆ°å³æ’æˆä¸€æ’ï¼Œç¬¬ i ååŒå­¦çš„èº«é«˜ä¸º hiã€‚ç°åœ¨å¼ è€å¸ˆæƒ³æ”¹å˜æ’é˜Ÿçš„é¡ºåºï¼Œä»–èƒ½è¿›è¡Œä»»æ„å¤šæ¬¡ï¼ˆåŒ…æ‹¬0æ¬¡ï¼‰å¦‚ä¸‹æ“ä½œï¼š

\- å¦‚æœä¸¤ååŒå­¦ç›¸é‚»ï¼Œå¹¶ä¸”ä»–ä»¬çš„èº«é«˜ä¹‹å·®ä¸è¶…è¿‡ Dï¼Œé‚£ä¹ˆè€å¸ˆå°±èƒ½äº¤æ¢ä»–ä¿©çš„é¡ºåºã€‚

è¯·ä½ å¸®å¼ è€å¸ˆç®—ä¸€ç®—ï¼Œé€šè¿‡ä»¥ä¸Šæ“ä½œï¼Œå­—å…¸åºæœ€å°çš„æ‰€æœ‰åŒå­¦ï¼ˆä»å·¦åˆ°å³ï¼‰èº«é«˜åºåˆ—æ˜¯ä»€ä¹ˆï¼Ÿ

**è¾“å…¥**

ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•° $N, D (1â‰¤Nâ‰¤10^5, 1â‰¤Dâ‰¤10^9)$ã€‚
æ¥ä¸‹å» N è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ­£æ•´æ•° hi (1<=hi<=109) è¡¨ç¤ºä»å·¦åˆ°å³æ¯ååŒå­¦çš„èº«é«˜ã€‚

è¾“å‡º

è¾“å‡º N è¡Œï¼Œç¬¬ i è¡Œè¡¨ç¤ºç­”æ¡ˆä¸­ç¬¬ i ååŒå­¦çš„èº«é«˜ã€‚

æ ·ä¾‹è¾“å…¥

```
5 3
7
7
3
6
2
```

æ ·ä¾‹è¾“å‡º

```
6
7
7
2
3
```

æç¤º

ã€æ ·ä¾‹è§£é‡Šã€‘
ä¸€ç§äº¤æ¢ä½ç½®çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š
`7 7 3 6 2-> 7 7 6 3 2-> 7 7 6 2 3-> 7 6 7 2 3-> 6 7 7 2 3`

ã€æ•°æ®èŒƒå›´å’Œçº¦å®šã€‘
å¯¹äº 10% çš„æ•°æ®ï¼Œæ»¡è¶³ Nâ‰¤100ï¼›
å¯¹äºå¦å¤– 20% çš„æ•°æ®ï¼Œæ»¡è¶³ Nâ‰¤5000ï¼›
å¯¹äºå…¨éƒ¨æ•°æ®ï¼Œæ»¡è¶³ $1â‰¤Nâ‰¤10_5, 1â‰¤Dâ‰¤10^9, 1â‰¤h_iâ‰¤10^9$ã€‚





æ“ä½œè§„åˆ™ï¼šè‹¥ç›¸é‚»ä¸¤äººé«˜åº¦å·® â‰¤ Dï¼Œåˆ™å¯ä»¥äº¤æ¢ã€‚

æ„å‘³ç€ï¼š

- ä¸¤ä¸ªäººå¦‚æœèƒ½é€šè¿‡ä¸€ç³»åˆ—ç›¸é‚»äº¤æ¢ï¼ˆéƒ½æ»¡è¶³å·® â‰¤ Dï¼‰è€Œåˆ°è¾¾å½¼æ­¤ä½ç½®ï¼Œä»–ä»¬å°±åœ¨**åŒä¸€ä¸ªå¯äº¤æ¢è¿é€šåˆ†é‡**é‡Œã€‚
- æ¯ä¸ªè¿é€šåˆ†é‡å†…éƒ¨çš„åŒå­¦ï¼Œå¯ä»¥ä»»æ„æ’åºï¼ˆå› ä¸ºäº¤æ¢æ˜¯å¯ä¼ é€’çš„ï¼‰ã€‚ä¸åŒåˆ†é‡ä¹‹é—´ä¸èƒ½è¶Šç•Œäº¤æ¢ã€‚

------

- **è´ªå¿ƒä¿è¯å­—å…¸åºæœ€å°**ï¼š
  - æ¯è½®åªæ”¶é›†èƒ½åŠ å…¥å½“å‰å—çš„å­¦ç”Ÿï¼ˆæ»¡è¶³æå€¼çº¦æŸï¼‰ã€‚
  - ç»„å†…æ’åºä¿è¯å—å†…å‡åºã€‚
  - å¤šè½®æ‰«æä¿è¯ä»å·¦å¾€å³çš„å—é¡ºåºä¹Ÿå°½é‡é å‰ï¼Œå¾—åˆ°å­—å…¸åºæœ€å°ã€‚
- **è¿­ä»£ + æå€¼åˆ¤æ–­**ï¼š
  - æ²¡æœ‰æ˜¾å¼æ„å»ºå›¾ï¼Œä¹Ÿæ²¡æœ‰ç”¨ DFS/BFSï¼Œä½†**é€šè¿‡æ‰«æ + æ›´æ–°æå€¼ + checked æ ‡è®°**ï¼Œç­‰ä»·äº**æ‰¾åˆ°äº†æ¯ä¸ªå¯äº¤æ¢è¿é€šå—**ã€‚
  - æ¯ä¸ªå—å†…çš„å­¦ç”Ÿä¹‹é—´å¯ä»¥è‡ªç”±äº¤æ¢ï¼Œæ­£æ˜¯è¿é€šåˆ†é‡çš„ç‰¹æ€§ã€‚

```python
import sys
input = sys.stdin.readline

N, D = map(int, input().split())
height = [int(input()) for _ in range(N)]

checked = [False] * N
remaining = N
result = []

while remaining > 0:	# åªè¦è¿˜æœ‰æœªå¤„ç†çš„ä½ç½®ï¼Œå°±ç»§ç»­åšä¸€è½®"æ”¶é›†ç»„"
    buffer = []
    i = 0
    # æ¯è½®ä»å·¦åˆ°å³å°è¯•æŠŠå¯å½’å…¥å½“å‰ buffer çš„æœªå¤„ç†å…ƒç´ æ ‡è®°å¹¶æ”¶é›†
    for i in range(N):
        if checked[i]:
            continue
        val = height[i]
        if not buffer:
            # buffer ä¸ºç©ºæ—¶ï¼Œç›´æ¥åŠ å…¥ç¬¬ä¸€ä¸ªæœªå¤„ç†å…ƒç´ 
            buffer.append(val)
            maxh = val
            minh = val
            checked[i] = True
            remaining -= 1
            continue

        # âš ï¸ â€œå…ˆç”¨å½“å‰å…ƒç´ æ›´æ–° max/minï¼Œå†åˆ¤æ–­â€
        maxh = max(maxh, val)
        minh = min(minh, val)

        # è‹¥å‡è®¾æŠŠ val åŠ å…¥åä»æ»¡è¶³ä¸æå€¼çš„å·® â‰¤ Dï¼Œåˆ™çœŸæ­£åŠ å…¥
        if maxh - val <= D and val - minh <= D:
            buffer.append(val)
            checked[i] = True
            remaining -= 1
        
    buffer.sort()
    result.extend(buffer)

print(*result, sep="\n")
```

å¤æ‚åº¦ï¼šæœ€åæƒ…å†µæ¥è¿‘ $O(k\cdot N + \sum |group|\log|group|)$ï¼ˆk ä¸ºè½®æ•°ï¼‰ã€‚æ¯è½®æ‰«æ N ä¸ªå…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šè¢«åŠ å…¥ä¸€æ¬¡ã€‚å—å†…æ’åºåŠ  O(N log N)ã€‚



ã€æ—å¥•å¦ƒ 2025fall-cs201, ç¯å¢ƒç§‘å­¦ä¸å·¥ç¨‹å­¦é™¢ã€‘æ€è·¯ï¼šèŠ‚ç‚¹æ•°Né«˜è¾¾ 10^5ã€‚å¦‚æœæ˜¯ç¨ å¯†å›¾ï¼ˆä¾‹å¦‚Då¾ˆå°ï¼Œå¤§éƒ¨åˆ†äººäº’æ–¥ï¼‰ï¼Œè¾¹çš„æ•°é‡å¯èƒ½è¾¾åˆ° O(N^2)ï¼Œç›´æ¥å»ºå›¾å’Œè®¡ç®—å…¥åº¦ä¼šè¶…æ—¶ï¼ˆTLEï¼‰å¹¶è¶…å†…å­˜ï¼ˆMLEï¼‰ï¼Œæ‰€ä»¥ä¸èƒ½å»ºå›¾ã€‚æ­¤é¢˜ä¸æ­¤å‰æœ€å°æ•°ç±»ä¼¼ï¼Œä½†æ˜¯å¤šäº†ä¸€ä¸ªäº¤æ¢çš„é™åˆ¶æ¡ä»¶ï¼Œå› æ­¤åœ¨é€ä¸ªäº¤æ¢ä½¿æœ€å·¦è¾¹çš„å€¼æœ€å°æ—¶éœ€è¦è¿›è¡Œåˆ¤æ–­ï¼Œè‹¥æ— æ³•ç»§ç»­äº¤æ¢åˆ™æ”¾å¼ƒæ­¤å¤„è·³è‡³ä¸‹ä¸€ä¸ªæ•°å­—å¤„ã€‚å¦‚æ­¤ç¡®å®šäº†æœ€å·¦è¾¹ä¹‹åå†ç¡®å®å·¦è¾¹ç¬¬äºŒä¸ªï¼Œä»¥æ­¤ç±»æ¨ã€‚ä½†å¦‚æœåªæ˜¯å¿«æ’ä¾ç„¶æ— æ³•è¾¾åˆ°æ—¶é—´è¦æ±‚ï¼Œæ‰€ä»¥å‚è€ƒç¾¤ä¸­çš„æ€è·¯é‡‡å–åŸºå‡†å€¼æ¯”è¾ƒçš„æ–¹æ³•ã€‚

```python
import sys
sys.setrecursionlimit(200000)

def quick_sort_constrained(d, num_list):
    # é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼šåˆ—è¡¨ä¸ºç©º
    if not num_list:
        return []

    # 1. é€‰å–åŸºå‡†ï¼šé˜Ÿä¼çš„ç¬¬ä¸€ååŒå­¦
    pivot = num_list[0]

    left = []  # å­˜æ”¾èƒ½æ’åˆ° pivot å·¦è¾¹çš„åŒå­¦
    right = []  # å­˜æ”¾åªèƒ½æ’åœ¨ pivot å³è¾¹çš„åŒå­¦

    # åˆå§‹åŒ–é˜»æŒ¡åŒºé—´çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ï¼Œæœ€å¼€å§‹é˜»æŒ¡åŒºé—´é‡Œåªæœ‰ pivot ä¸€ä¸ªäºº
    max_blocker = pivot
    min_blocker = pivot

    # 2. éå†å‰©ä¸‹çš„äººï¼Œè¿›è¡Œâ€œåˆ’åˆ†â€
    for num in num_list[1:]:
        # åˆ¤æ–­èƒ½å¦å»å·¦è¾¹ï¼š
        # æ¡ä»¶1: å¿…é¡»æ¯” pivot å° (å­—å…¸åºè¦æ±‚)
        # æ¡ä»¶2: å¿…é¡»èƒ½è·Ÿâ€œé˜»æŒ¡ç»„â€é‡Œæœ€é«˜çš„äººäº¤æ¢ (max_blocker - num <= d)
        # æ¡ä»¶3: å¿…é¡»èƒ½è·Ÿâ€œé˜»æŒ¡ç»„â€é‡Œæœ€çŸ®çš„äººäº¤æ¢ (num - min_blocker <= d)
        if num < pivot and (max_blocker - num <= d) and (num - min_blocker <= d):
            left.append(num)
        else:
            right.append(num)	# å»å³è¾¹ï¼Œå¹¶åŠ å…¥â€œé˜»æŒ¡ç»„â€
            # æ›´æ–°é˜»æŒ¡ç»„çš„æœ€å€¼
            if num > max_blocker:
                max_blocker = num
            if num < min_blocker:
                min_blocker = num

    # 3. é€’å½’åˆå¹¶ç»“æœï¼šå·¦è¾¹æ’å¥½åº + [åŸºå‡†] + å³è¾¹æ’å¥½åº
    #return quick_sort_constrained(d, left) + [pivot] + quick_sort_constrained(d, right)
    return sorted(left) + [pivot] + quick_sort_constrained(d, right)

def solve():
    # ä½¿ç”¨ sys.stdin.read å¿«é€Ÿè¯»å–æ‰€æœ‰è¾“å…¥
    input_data = sys.stdin.read().split()
    if not input_data:
        return

    iterator = iter(input_data)
    try:
        N = int(next(iterator))
        D = int(next(iterator))
        # è¯»å–å‰©ä½™çš„ N ä¸ªèº«é«˜æ•°æ®
        heights = [int(next(iterator)) for _ in range(N)]
    except StopIteration:
        return

    # è°ƒç”¨æ’åºå‡½æ•°
    result = quick_sort_constrained(D, heights)
    print('\n'.join(map(str, result)))

if __name__ == "__main__":
    solve()
```





ã€é‡‘äºç‘ 25å·¥å­¦é™¢ã€‘æ€è·¯ï¼šç¡®å®æœ‰â€œç‚¹â€è¶…çº²äº†ã€‚å…ˆæ˜¯æƒ³äº†å„ç§åˆ’åˆ†åˆ†æ²»ç­‰ç­‰çš„æƒ³æ³•ï¼Œä½†æ˜¯éƒ½æ²¡ç”¨ï¼Œåé¢è¯•ç€ç”¨è´ªå¿ƒç»™å‡ºäº†ä¸€ä¸ªè§£æ³•ï¼Œç»“æœTLEã€‚å› ä¸ºæˆ‘çš„è´ªå¿ƒéœ€è¦é‡å¤éå†åå‡ ä½å…ƒç´ ï¼Œå¯¹æ¯”å¹¶é¡ºä¾¿æ‰¾åˆ°æœ€ä½³çš„æ’å…¥ä½ç½®ï¼Œæ‰€ä»¥æˆ‘æŠŠæ•°æ®ç»“æ„æ”¹æˆäº†è‡ªå·±å®ç°çš„é“¾è¡¨æ¥æå‡insertçš„æ•ˆç‡ï¼ˆè¿™æ ·å¯ä»¥åœ¨æ‰¾åˆ°æ’å…¥ç‚¹åæ–¹çš„å¯¹è±¡ååä»¥Oï¼ˆ1ï¼‰æ¥æ’å…¥ï¼‰ï¼Œç»“æœæ”¹å®Œè¿˜æ˜¯TLEï¼Œæœ‰ç‚¹ç ´é˜²äº†ã€‚ç„¶ååœ¨ç¾¤é‡Œçœ‹è§å¤§ä¼™æåˆ°ä¸€ä¸ªDAGï¼Œæˆ‘ä¸Šç½‘äº†è§£å­¦ä¹ äº†ä¸€ä¸‹ï¼ŒçŸ¥é“äº†è¿™é¢˜æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæ‹“æ‰‘æ’åºé—®é¢˜ï¼ŒæŠ“ä½**å…¥åº¦**è¿™ä¸ªå…³é”®æ¦‚å¿µè¿›è¡Œåˆ†ç»„å’Œç»„å†…çš„å‡åºæ’åˆ—ï¼Œæœ€ç»ˆACã€‚è™½ç„¶ä»£ç ä¸æ€ä¹ˆç®€æ´ï¼Œä½†æ˜¯èƒ½è·‘å¾—åŠ¨çš„ä»£ç å°±æ˜¯å¥½ä»£ç ğŸ‘

```python
import sys
from collections import deque

input = sys.stdin.readline

n, d = map(int, input().split())
q = deque(int(input()) for _ in range(n))

ans = []
group = [q.popleft()]
max_h = min_h = group[0]
wait = deque()

while q:
    h = q.popleft()
    if min_h + d >= h >= max_h - d:
        group.append(h)
        max_h = max(max_h, h)
        min_h = min(min_h, h)
    else:
        wait.append(h)
        max_h = max(max_h, h)
        min_h = min(min_h, h)
        if max_h - min_h > 2 * d:
            ans.extend(sorted(group))
            group.clear()
            # å›æ”¾ç­‰å¾…åŒº
            while wait:
                q.appendleft(wait.pop())
            max_h = min_h = q[0] if q else 0
            if q:
                group.append(q.popleft())
    # æœ€åé˜¶æ®µçš„ç»“å°¾è¡¥å…¨
    if not q:
        ans.extend(sorted(group))
        group.clear()
        if wait:
            while wait:
                q.appendleft(wait.pop())
            max_h = min_h = q[0]
            group.append(q.popleft())

print("\n".join(map(str, ans)))
```





ã€æ®µå­ä¿Š 25 ç‰©ç†å­¦é™¢ã€‘è¿™æ¬¡è€ƒè¯•æœ‰è¿›æ­¥æˆ‘è§‰å¾—ï¼Œé›¶åŸºç¡€ï¼Œä¸Šæ¬¡æœˆè€ƒåªå†™å¯¹ä¸‰é“ï¼Œè¿™æ¬¡ç›´æ¥å†™å¯¹äº”é“ï¼Œå°±åªæœ‰æ’é˜Ÿä¸ä¼šï¼Œæ’é˜Ÿæˆ‘ä¸Šæ¬¡å°±çœ‹è¿‡ï¼Œé–æˆ˜å››æ—¶ï¼Œæ®šç²¾ç«­è™‘ï¼Œè¿å‡ºä¸‰ç­–ï¼Œæœªå°ä¸€è¿‡ï¼Œè´¥å…´è€Œå»ï¼Œç„¶åè¿™æ¬¡è€ƒè¯•æƒ³äº†åŠä¸ªå°æ—¶ï¼Œå°±æ˜¯ç”¨æˆ‘æœ€åä¸€ä¸ªæ–¹æ³•ï¼Œå…ˆå°†æ‰€æœ‰èƒ½æ’ç¬¬ä¸€ä½çš„æå‡ºæ¥ï¼Œæ’å‡ºæœ€å°çš„ï¼Œæ”¾åœ¨ç¬¬ä¸€ä½ï¼Œä»¥æ­¤ç±»æ¨ï¼Œç»“æœè¿˜æ˜¯è¶…æ—¶ï¼Œç„¶åæ™šä¸Šåˆè‹¦æ€å†¥æƒ³ï¼ŒåºŸå¯å¿˜é£Ÿï¼Œç»ˆäºå¤§æ‚Ÿï¼Œä¸€è¨€ä»¥è”½ä¹‹ï¼Œå°±æ˜¯èƒ½æ’ç¬¬ä¸€ä½çš„æ•°ä¸€å®šæ¯”ä¸èƒ½æ’ç¬¬ä¸€ä½çš„æ•°åœ¨ç»“æœä¸Šæ’åœ¨å‰ï¼Œè¿™æ ·æ¯æ¬¡å°±å¯ä»¥æå‡ºä¸€ä¸ªåºåˆ—ï¼Œä¼šå¿«å¾ˆå¤šï¼ˆæˆ‘æœ€å¼€å§‹çš„æ–¹æ³•ä¸€æ¬¡è¿­ä»£åªèƒ½æ’ä¸€ä¸ªï¼Œè€Œç°åœ¨èƒ½æ’ä¸€ä¸ªåºåˆ—ï¼Œä½†æœ¬è´¨ä¸Šæ˜¯ä¸€æ ·çš„ï¼‰ï¼ˆåˆ¤æ–­èƒ½ä¸èƒ½æ’ç¬¬ä¸€ä½å°±æ˜¯çœ‹è¿™ä¸ªæ•°æ˜¯å¦éƒ½èƒ½åè½äºå®ƒå‰é¢çš„æ•°çš„ã€x-d,x+dã€‘é‚»åŸŸå†…ï¼‰ï¼Œç„¶åå†™å‡ºä»£ç python3ç”¨224mså°±è¿‡äº†ï¼Œåœ¨ç»Ÿè®¡æ¦œé‡Œåº”è¯¥æ˜¯éå¸¸å¿«çš„ï¼Œåæ­£æˆ‘æ²¡çœ‹åˆ°æ¯”æˆ‘å¿«çš„ï¼ŒçœŸæ˜¯å†™çˆ½äº†ï¼Œå‰é¢äº”é¢˜æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œåœ¨è€ƒåœºä¸Šéƒ½åšå‡ºæ¥äº†

```python
import sys
from collections import deque

n, d = map(int, sys.stdin.readline().split())
l = deque(map(int, sys.stdin.read().split()))
out = []

while l:
    m = deque()
    p = l.popleft()
    left, right = p - d, p + d
    r = [p]
    L = len(l)  # å›ºå®šå¾ªç¯æ¬¡æ•°
    for _ in range(L):
        q = l.popleft()
        left = max(left, q - d)
        right = min(right, q + d)
        if right < left:
            l.appendleft(q)  # æŠŠ q æ”¾å›å»ï¼
            break
        if left <= q <= right:
            r.append(q)
        else:
            m.append(q)
    l.extend(m)  # m æ”¾åˆ°æœ«å°¾
    r.sort()
    out.extend(r)

print('\n'.join(map(str, out)))
```





è´ªå¿ƒæ³•ã€‚ä»æœ€å·¦ä¾§çš„è¾“å…¥é«˜åº¦æ‰¾èµ·ï¼ŒæŒ‰ç…§çº¦æŸæ¡ä»¶éƒ½æ‰¾å‡ºæ¥ï¼ŒåŠ å…¥æš‚å­˜åˆ—è¡¨ã€æ’åºã€åŒæ—¶æ ‡å¿—æ”¹ä¸ºTrueã€‚å¾ªç¯æ‰¾æ¥ä¸‹æ¥è¿˜æ²¡æœ‰å…¥é€‰çš„ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231017133436664.png" alt="image-20231017133436664" style="zoom: 50%;" />



402ms

```python
#  è‹ç‹æ· 2300011075
N, D = map(int, input().split())
height = [0]*N
check = [False]*N
for i in range(N):
    height[i] = int(input())

height_new = []
while False in check:
    i, l = 0, len(height)
    buffer = []
    while i < l:
        if check[i]:
            i += 1
            continue
        if len(buffer) == 0:
            buffer.append(height[i])
            maxh = height[i]
            minh = height[i]
            check[i] = True
            continue

        maxh = max(height[i], maxh)
        minh = min(height[i], minh)
        if maxh-height[i] <= D and height[i]-minh <= D:
            buffer.append(height[i])
            check[i] = True
        i += 1
    buffer.sort()
    height_new.extend(buffer)

print(*height_new, sep='\n')
```

ä»£ç ä½¿ç”¨çš„ `buffer` ç¡®å®æ˜¯ä¸€ç§ **å±€éƒ¨æ¸…ç©º** æŠ€å·§ã€‚è¿™ç§æŠ€æœ¯åœ¨é—®é¢˜æ±‚è§£è¿‡ç¨‹ä¸­ï¼Œé€šè¿‡ **é€æ­¥å¤„ç†å’Œæ¸…ç©ºå±€éƒ¨æ•°æ®**ï¼Œé¿å…äº†ä¸å¿…è¦çš„å…¨å±€çŠ¶æ€å­˜å‚¨ï¼Œä»è€Œç®€åŒ–äº†ç®—æ³•é€»è¾‘ï¼ŒåŒæ—¶è¿˜èƒ½åœ¨ä¸€å®šç¨‹åº¦ä¸Šæå‡æ•ˆç‡ã€‚



339ms

```python
N, D = map(int, input().split())
h = [int(input()) for _ in range(N)]
used = [0] * N

while 0 in used:
    free = []
    for i in range(N):
        if used[i]:
            continue
        if not free:
            minv = h[i]
            maxv = h[i]
        else:
            if h[i] > maxv:
                maxv = h[i]
            if h[i] < minv:
                minv = h[i]

        if maxv - minv > 2*D:
            break

        if (h[i] + D >= maxv and h[i] - D <= minv):
            free.append(h[i])
            used[i] = 1
    free.sort()
    for v in free:
        print(v)
```



è´ªå¿ƒï¼šå­—å…¸åºæœ€å°å¿…è¦ç¬¬ä¸€ä½ä¸Šæœ€å°ï¼›åŒæ—¶æ³¨æ„åˆ°æœ‰ç±»ä¼¼å›¾çš„â€œè”é€šâ€æ€§è´¨â€”â€”ä¸æœ€é«˜mxå’Œæœ€ä½mnè·ç¦»éƒ½ä¸è¶…è¿‡dçš„åŒå­¦å¯ä»¥ç§»åˆ°æœ€å‰é¢â€”â€”å°†è¿™äº›äººæ”¾å…¥tmpæ•°ç»„ï¼Œè¿›è¡Œsortæ’åºã€‚
æ¯æ¬¡éœ€è¦æŠŠæ”¾å…¥tmpæ•°ç»„çš„äººä»å¾…é€‰åˆ—è¡¨ä¸­å»é™¤ï¼Œç”¨é“¾è¡¨å¯ä»¥å®ç°ï¼Œå»é™¤åªéœ€æŠŠiçš„preè¿åˆ°içš„nextä¸Šå³å¯ã€‚

```python
#å¾å‰ 25ç‰©ç†å­¦é™¢
n, d = map(int, input().split())
q = [[int(input()), i - 1, i + 1] for i in range(n)]  # hi, pre, next
start = [0]  # ç”¨åˆ—è¡¨åŒ…ä¸€å±‚ï¼Œæ–¹ä¾¿å‡½æ•°é‡Œæ”¹
tail = n

def remove(i):
    if i == start[0]:
        start[0] = q[i][2]
    else:
        q[q[i][1]][2] = q[i][2]
    if q[i][2] != tail:
        q[q[i][2]][1] = q[i][1]

ans = []
while start[0] != tail:
    tmp = []
    i = start[0]
    mn = mx = q[i][0]
    while i != tail:
        x = q[i][0]
        if mx - d <= x <= mn + d:
            tmp.append(x)
            nxt = q[i][2]
            remove(i)
            i = nxt
        else:
            i = q[i][2]
        mn = min(mn, x)
        mx = max(mx, x)
        if mx - mn > 2 * d:
            break
    ans.extend(sorted(tmp))

print(*ans, sep='\n')

```



ä¸Šé¢è¿™ä»½ä»£ç é‡Œç”¨äºŒç»´æ•°ç»„ `q[i] = [hi, pre, next]` æ¥æ¨¡æ‹Ÿé“¾è¡¨ï¼Œæ˜¯â€œæ‰‹å·¥é“¾è¡¨â€äº†ã€‚å¯ä»¥ç”¨é¢å‘å¯¹è±¡ï¼ˆOOPï¼‰çš„æ–¹å¼å°è£…æˆä¸€ä¸ª `Node` ç±»å’Œä¸€ä¸ª `LinkedList` ç±»ï¼Œä»£ç ä¼šæ›´ç›´è§‚ï¼Œä¹Ÿæ–¹ä¾¿ç»´æŠ¤ã€‚ä¸‹é¢æ˜¯ OOP é£æ ¼ï¼š

```python
class Node:
    def __init__(self, value, idx):
        self.value = value
        self.prev = idx - 1
        self.next = idx + 1

class LinkedList:
    def __init__(self, n):
        self.nodes = []
        for i in range(n):
            val = int(input())
            self.nodes.append(Node(val, i))
        self.start = 0
        self.tail = n  # å“¨å…µ

    def remove(self, idx):
        """ä»é“¾è¡¨ä¸­ç§»é™¤èŠ‚ç‚¹ idx"""
        node = self.nodes[idx]
        if idx == self.start:           # åˆ é™¤å¤´èŠ‚ç‚¹
            self.start = node.next
        else:                           # å·¦é‚»å±…æŒ‡å‘å³é‚»å±…
            self.nodes[node.prev].next = node.next
        if node.next != self.tail:      # å³é‚»å±…ä¸æ˜¯å“¨å…µ
            self.nodes[node.next].prev = node.prev
        # æ³¨æ„ï¼štail æ°¸è¿œä¿æŒ nï¼Œä¸è¦æ”¹ï¼

    def iterate(self, d):
        """æ‰§è¡Œè´ªå¿ƒé€»è¾‘ï¼Œè¿”å›ç»“æœåˆ—è¡¨"""
        ans = []
        start, tail = self.start, self.tail
        while start != tail:
            tmp = []
            mn = mx = self.nodes[start].value
            i = start
            while i != tail:
                x = self.nodes[i].value
                if mx - d <= x <= mn + d:
                    tmp.append(x)
                    nxt = self.nodes[i].next
                    self.remove(i)
                    i = nxt
                else:
                    i = self.nodes[i].next
                mn = min(mn, x)
                mx = max(mx, x)
                if mx - mn > 2 * d:
                    break
            ans.extend(sorted(tmp))
            start, tail = self.start, self.tail
        return ans


if __name__ == "__main__":
    n, d = map(int, input().split())
    ll = LinkedList(n)
    ans = ll.iterate(d)
    print(*ans, sep='\n')
```





278msã€‚ç¬¬16è¡Œï¼šå¯ä»¥ç§»åˆ°æœ€å‰ç«¯çš„éƒ½popæ‰äº†ï¼Œå‰©ä¸‹çš„popåé‡æ–°è¡¥åˆ°åˆ—è¡¨å°¾éƒ¨ï¼Œæ°å¥½å®ç°äº†ä¸€è½®ç­›é€‰ï¼Œå¹¶ä¸”å‰©ä¸‹çš„ä¿æŒåŸæ¥çš„æ’åˆ—é¡ºåºã€‚è¿™æ ·å†™çš„è¯ï¼Œå¿…é¡»éå†å®Œæ•´ã€‚    

```python
from collections import deque

n, d = map(int, input().split())
h = deque(int(input()) for _ in range(n))
ans = []

while h:
    inlist = []
    max_val = h[0]
    min_val = h[0]
    
    # ä¸€æ¬¡éå†å®Œæˆæ‰€æœ‰å¿…è¦çš„è®¡ç®—
    for _ in range(len(h)):
        height = h.popleft()
        if abs(height - max_val) <= d and abs(height - min_val) <= d:
            inlist.append(height)
        else:
            h.append(height)
        
        if height < min_val:
            min_val = height
        if height > max_val:
            max_val = height
        
    
    ans += sorted(inlist)

print(*ans, sep='\n')
```



<mark>æ ‘çŠ¶æ•°ç»„</mark>è§£æ³•ã€‚

**é—®é¢˜æ ¸å¿ƒåˆ†æ**

**1. äº¤æ¢è§„åˆ™ä¸é™åˆ¶**
é¢˜ç›®å…è®¸äº¤æ¢ç›¸é‚»çš„ä¸¤ä¸ªåŒå­¦ï¼Œå½“ä¸”ä»…å½“ä»–ä»¬çš„èº«é«˜å·® $|h_i - h_{i+1}| \le D$ã€‚
è¿™å®é™…ä¸Šå®šä¹‰äº†ä¸€ä¸ª**ä¸å¯äº¤æ¢**çš„æ¡ä»¶ï¼ˆå³â€œé˜»å¡â€æ¡ä»¶ï¼‰ï¼š
å¦‚æœä¸¤ä¸ªåŒå­¦ $i$ å’Œ $j$ï¼ˆå‡è®¾ $i$ åŸæœ¬åœ¨ $j$ å·¦è¾¹ï¼Œå³ $i < j$ï¼‰ï¼Œä¸”ä»–ä»¬çš„èº«é«˜å·® $|h_i - h_j| > D$ï¼Œé‚£ä¹ˆä»–ä»¬**æ°¸è¿œæ— æ³•äº¤æ¢ä½ç½®**ã€‚
è¿™æ„å‘³ç€ï¼šåœ¨æœ€ç»ˆçš„åºåˆ—ä¸­ï¼Œ$h_i$ å¿…é¡»ä¾ç„¶æ’åœ¨ $h_j$ çš„å‰é¢ã€‚

**2. è½¬åŒ–ä¸ºæœ‰å‘æ— ç¯å›¾ (DAG) çš„æ‹“æ‰‘æ’åº**
æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªé—®é¢˜çœ‹ä½œæ˜¯ä¸€ä¸ªå›¾è®ºé—®é¢˜ï¼š

*   **èŠ‚ç‚¹**ï¼šæ¯ä¸ªä½ç½®ä¸Šçš„åŒå­¦ã€‚
*   **æœ‰å‘è¾¹**ï¼šå¯¹äºä»»æ„ä¸€å¯¹ $(i, j)$ï¼Œå¦‚æœ $i < j$ ä¸” $|h_i - h_j| > D$ï¼Œåˆ™å­˜åœ¨ä¸€æ¡ä» $i$ æŒ‡å‘ $j$ çš„è¾¹ï¼ˆä»£è¡¨ $i$ å¿…é¡»åœ¨ $j$ ä¹‹å‰ï¼‰ã€‚
*   **ç›®æ ‡**ï¼šåœ¨æ»¡è¶³æ‰€æœ‰è¿™äº›å‰åé™åˆ¶çš„æƒ…å†µä¸‹ï¼Œæ±‚å­—å…¸åºæœ€å°çš„åºåˆ—ã€‚è¿™æœ¬è´¨ä¸Šæ˜¯æ±‚è¿™ä¸ª DAG çš„**å­—å…¸åºæœ€å°çš„æ‹“æ‰‘æ’åº**ã€‚

**3. ä¸ºä»€ä¹ˆä½¿ç”¨â€œåˆ†å±‚â€ç®—æ³•ï¼Ÿ**
ç›´æ¥å»ºå›¾è¾¹çš„æ•°é‡å¯èƒ½é«˜è¾¾ $O(N^2)$ï¼Œå¯¹äº $N=10^5$ æ¥è¯´ä¼šè¶…æ—¶ã€‚æˆ‘ä»¬éœ€è¦ä¸€ç§æ›´é«˜æ•ˆçš„æ–¹æ³•æ¥éšå¼åœ°å¤„ç†è¿™äº›è¾¹ã€‚
ä»£ç ä¸­ä½¿ç”¨äº†ä¸€ç§**åŸºäºâ€œå±‚æ•°â€ (Layer) çš„åŠ¨æ€è§„åˆ’**æ€æƒ³ï¼š

*   å®šä¹‰ $Layer(i)$ ä¸ºç¬¬ $i$ ä¸ªåŒå­¦åœ¨é€»è¾‘ä¸Šå¿…é¡»å¤„äºçš„â€œæ‰¹æ¬¡â€ã€‚
*   å¦‚æœ $i$ è¢«å·¦è¾¹çš„æŸä¸ª $k$ é˜»å¡ï¼ˆå³ $|h_k - h_i| > D$ï¼‰ï¼Œé‚£ä¹ˆ $i$ å¿…é¡»æ’åœ¨ $k$ åé¢ã€‚
*   è½¬ç§»æ–¹ç¨‹ï¼š$Layer(i) = 1 + \max(\{Layer(k) \mid k < i, |h_k - h_i| > D\} \cup \{0\})$ã€‚
*   æ¢å¥è¯è¯´ï¼Œ**$i$ çš„å±‚æ•°ç­‰äºæ‰€æœ‰èƒ½â€œæŒ¡ä½â€å®ƒçš„å·¦ä¾§åŒå­¦ä¸­æœ€å¤§çš„å±‚æ•°åŠ  1**ã€‚

**4. åŒå±‚æ€§è´¨**
åŒä¸€ä¸ª $Layer$ å†…çš„æ‰€æœ‰åŒå­¦ï¼Œå½¼æ­¤ä¹‹é—´ä¸€å®šæ»¡è¶³ $|h_a - h_b| \le D$ã€‚å¦‚æœä»–ä»¬ä¹‹é—´æœ‰é˜»å¡å…³ç³»ï¼Œä»–ä»¬å°±ä¸å¯èƒ½åœ¨åŒä¸€å±‚ã€‚
æ—¢ç„¶åŒå±‚å†…æ²¡æœ‰é˜»å¡å…³ç³»ï¼ˆå³å¯ä»¥ä¸¤ä¸¤äº¤æ¢ï¼‰ï¼Œä¸ºäº†ä½¿å­—å…¸åºæœ€å°ï¼Œæˆ‘ä»¬åªéœ€è¦å°†**æ¯ä¸€å±‚çš„åŒå­¦æŒ‰èº«é«˜ä»å°åˆ°å¤§æ’åº**è¾“å‡ºå³å¯ã€‚

---

**ä»£ç é€»è¾‘è¯¦ç»†è§£è¯»**

ä»£ç é€šè¿‡**æ ‘çŠ¶æ•°ç»„ (Fenwick Tree / BIT)** æ¥é«˜æ•ˆç»´æŠ¤å’ŒæŸ¥è¯¢åŒºé—´çš„æœ€å¤§å±‚æ•°ã€‚

**1. æ•°æ®ç¦»æ•£åŒ–**

ç”±äºèº«é«˜ $h_i$ é«˜è¾¾ $10^9$ï¼Œä¸èƒ½ç›´æ¥ç”¨ä½œæ•°ç»„ä¸‹æ ‡ã€‚

```python
vals = sorted(set(h))
M = len(vals)
rank = {v: i for i, v in enumerate(vals)} # å°†èº«é«˜æ˜ å°„åˆ° 0 ~ M-1
```

è¿™ä¸€æ­¥å°†èº«é«˜æ˜ å°„ä¸ºç›¸å¯¹æ’åï¼ˆRankï¼‰ï¼Œç”¨äºåœ¨æ ‘çŠ¶æ•°ç»„ä¸­å®šä½ã€‚

**2. æ ‘çŠ¶æ•°ç»„ (Fenwick Tree) çš„ä½œç”¨**

ä»£ç å®šä¹‰äº† `bit_update` å’Œ `bit_query`ï¼Œç”¨äºç»´æŠ¤**å‰ç¼€æœ€å¤§å€¼**ã€‚
æˆ‘ä»¬éœ€è¦ä¸¤æ£µæ ‘çŠ¶æ•°ç»„ï¼š

*   `bitL`: ç»´æŠ¤æ­£å‘çš„èº«é«˜ã€‚ç”¨äºæŸ¥è¯¢èº«é«˜ **å°äº** $h_i - D$ çš„é‚£äº›åŒå­¦ä¸­ï¼Œæœ€å¤§çš„å±‚æ•°æ˜¯å¤šå°‘ã€‚
*   `bitR`: ç»´æŠ¤åå‘çš„èº«é«˜ã€‚ç”¨äºæŸ¥è¯¢èº«é«˜ **å¤§äº** $h_i + D$ çš„é‚£äº›åŒå­¦ä¸­ï¼Œæœ€å¤§çš„å±‚æ•°æ˜¯å¤šå°‘ã€‚

**3. æ ¸å¿ƒå¾ªç¯ï¼šè®¡ç®—æ¯ä¸ªåŒå­¦çš„ Layer**

éå†æ¯ä¸ªåŒå­¦çš„èº«é«˜ `hi`ï¼š

* **æŸ¥æ‰¾å·¦ä¾§é˜»å¡è€… (Small Blockers)**ï¼š
  æˆ‘ä»¬éœ€è¦æ‰¾å·¦ä¾§èº«é«˜åœ¨åŒºé—´ $(-\infty, h_i - D - 1]$ èŒƒå›´å†…çš„æœ€å¤§å±‚æ•°ã€‚

  ```python
  L = bisect.bisect_left(vals, hi - D)
  left_max = bit_query(bitL, L) if L > 0 else 0
  ```

  `bitL` å­˜å‚¨çš„æ˜¯ä»¥èº«é«˜ Rank ä¸ºç´¢å¼•çš„å±‚æ•°æœ€å¤§å€¼ã€‚`bisect` æ‰¾åˆ°äº†å¯¹åº”çš„ç¦»æ•£åŒ–è¾¹ç•Œã€‚

* **æŸ¥æ‰¾å³ä¾§é˜»å¡è€… (Large Blockers)**ï¼š
  æˆ‘ä»¬éœ€è¦æ‰¾å·¦ä¾§èº«é«˜åœ¨åŒºé—´ $[h_i + D + 1, +\infty)$ èŒƒå›´å†…çš„æœ€å¤§å±‚æ•°ã€‚

  ```python
  R = bisect.bisect_right(vals, hi + D)
  if R < M:
      posR = M - R # æ³¨æ„è¿™é‡Œï¼šä¸ºäº†ç”¨å‰ç¼€æœ€å¤§å€¼çš„BITæŸ¥åç¼€ï¼Œç”¨äº† M - index
      right_max = bit_query(bitR, posR)
  ```

  `bitR` ä½¿ç”¨äº†ä¸€ä¸ªæŠ€å·§ï¼šå®ƒå°†èº«é«˜å€’è¿‡æ¥æ˜ å°„ã€‚æŸ¥è¯¢ `bitR` çš„å‰ç¼€å®é™…ä¸Šæ˜¯åœ¨æŸ¥è¯¢åŸèº«é«˜çš„åç¼€ï¼ˆå³å¤§æ•°å€¼éƒ¨åˆ†ï¼‰ã€‚

* **è®¡ç®—å½“å‰å±‚æ•°å¹¶å­˜å‚¨**ï¼š

  ```python
  cur_layer = max(left_max, right_max) + 1
  max_layer = max(max_layer, cur_layer)
  layer_buckets.setdefault(cur_layer, []).append(hi)
  ```

  ç®—å‡ºå±‚æ•°åï¼Œå°†è¯¥èº«é«˜æ”¾å…¥å¯¹åº”çš„æ¡¶ï¼ˆBucketï¼‰ä¸­ã€‚

* **æ›´æ–°æ ‘çŠ¶æ•°ç»„**ï¼š
  å°†å½“å‰åŒå­¦çš„èº«é«˜å’Œè®¡ç®—å‡ºçš„å±‚æ•°æ›´æ–°è¿› `bitL` å’Œ `bitR`ï¼Œè®©ä»–æˆä¸ºåç»­åŒå­¦çš„æ½œåœ¨é˜»å¡è€…ã€‚

  ```python
  s = rank[hi]
  bit_update(bitL, s + 1, cur_layer)
  bit_update(bitR, M - s, cur_layer)
  ```

**4. è¾“å‡ºç­”æ¡ˆ**

```python
for layer in range(1, max_layer + 1):
    if layer in layer_buckets:
        for v in sorted(layer_buckets[layer]):
            out_lines.append(str(v))
```

æŒ‰å±‚å·ä»å°åˆ°å¤§éå†ï¼Œå¯¹äºæ¯ä¸€å±‚å†…éƒ¨ï¼ŒæŒ‰èº«é«˜ä»å°åˆ°å¤§æ’åºï¼ˆè´ªå¿ƒï¼Œå­—å…¸åºæœ€å°ï¼‰ï¼Œæ‹¼æ¥æˆç»“æœè¾“å‡ºã€‚

---

**ç®—æ³•å¤æ‚åº¦**

1.  **ç¦»æ•£åŒ–**: $O(N \log N)$ (æ’åº)ã€‚
2.  **è®¡ç®—å±‚æ•°**: å¯¹æ¯ä¸ªå…ƒç´ è¿›è¡Œ BIT æŸ¥è¯¢å’Œæ›´æ–°ã€‚BIT æ“ä½œæ˜¯ $O(\log N)$ï¼Œå…± $N$ æ¬¡ã€‚æ€»è®¡ $O(N \log N)$ã€‚
3.  **è¾“å‡ºæ’åº**: ç›¸å½“äºå¯¹æ•°ç»„è¿›è¡Œäº†åˆ†å—æ’åºï¼Œæœ€åæƒ…å†µä¹Ÿæ˜¯ $O(N \log N)$ã€‚

**æ€»æ—¶é—´å¤æ‚åº¦**: $O(N \log N)$ã€‚
è¿™è¶³ä»¥é€šè¿‡ $N=10^5$ çš„æ•°æ®èŒƒå›´ï¼ˆé€šå¸¸ Python éœ€è¦æ§åˆ¶åœ¨ 1-2ç§’å†…ï¼Œè¿™ä¸ªç®—æ³•éå¸¸é«˜æ•ˆï¼‰ã€‚

**æ ·ä¾‹æ¼”ç»ƒ**

è¾“å…¥ï¼š`5 3`ï¼Œåºåˆ— `7 7 3 6 2`

1.  **7**: å·¦è¾¹æ²¡æ•°ã€‚$Layer = 1$ã€‚`bit`æ›´æ–°: 7çš„ä½ç½®å­˜1ã€‚æ¡¶: `{1: [7]}`
2.  **7**: å·¦è¾¹ `7`ï¼Œå·®0 (<=3)ï¼Œä¸é˜»å¡ã€‚$Layer = 1$ã€‚`bit`æ›´æ–°: 7çš„ä½ç½®å­˜1ã€‚æ¡¶: `{1: [7, 7]}`
3.  **3**: å·¦è¾¹æœ‰ `7, 7`ã€‚
    *   $7 > 3+3$? æ˜¯ ($7>6$)ã€‚è¢«7é˜»å¡ã€‚
    *   æŸ¥å¾—7çš„å±‚æ•°æ˜¯1ã€‚
    *   $Layer = 1 + 1 = 2$ã€‚æ¡¶: `{1: [7,7], 2: [3]}`
4.  **6**: å·¦è¾¹æœ‰ `7(L1), 7(L1), 3(L2)`ã€‚
    *   $|7-6|=1 \le 3$ (ä¸é˜»å¡)ã€‚
    *   $|3-6|=3 \le 3$ (ä¸é˜»å¡)ã€‚
    *   æ²¡æœ‰è¢«é˜»å¡ã€‚$Layer = 1$ã€‚æ¡¶: `{1: [7,7,6], 2: [3]}`
5.  **2**: å·¦è¾¹æœ‰ `7(L1), 6(L1), 3(L2)...`ã€‚
    *   $7 > 2+3$ (é˜»å¡ï¼ŒMaxLayer=1)ã€‚
    *   $6 > 2+3$ (é˜»å¡ï¼ŒMaxLayer=1)ã€‚
    *   $3$ ä¸é˜»å¡ (å·®1)ã€‚
    *   æœ€å¤§é˜»å¡å±‚æ•°æ˜¯1ï¼Œæ‰€ä»¥ $Layer = 1 + 1 = 2$ã€‚æ¡¶: `{1: [7,7,6], 2: [3,2]}`

**æœ€ç»ˆå¤„ç†**:

*   Layer 1: `[7, 7, 6]` -> æ’åº -> `6, 7, 7`
*   Layer 2: `[3, 2]` -> æ’åº -> `2, 3`
*   åˆå¹¶: `6 7 7 2 3` (ä¸æ ·ä¾‹è¾“å‡ºä¸€è‡´)ã€‚



```python
import sys
import bisect

# å¢åŠ é€’å½’æ·±åº¦é™åˆ¶ï¼ˆè™½ç„¶æœ¬è§£æ³•ä¸»è¦é€šè¿‡è¿­ä»£å®ç°ï¼Œè¿™åœ¨å¤§è§„æ¨¡æ•°æ®ä¸‹æ˜¯å¥½ä¹ æƒ¯ï¼‰
sys.setrecursionlimit(200000)

def solve():
    # ä½¿ç”¨ sys.stdin.read ä¸€æ¬¡æ€§è¯»å–æ‰€æœ‰è¾“å…¥ï¼Œæ˜¾è‘—æå‡ Python I/O é€Ÿåº¦
    input_data = sys.stdin.read().split()
    
    if not input_data:
        return

    iterator = iter(input_data)
    
    try:
        N = int(next(iterator))
        D = int(next(iterator))
        # è¯»å– N ä¸ªåŒå­¦çš„èº«é«˜
        h = [int(next(iterator)) for _ in range(N)]
    except StopIteration:
        return

    # --- 1. ç¦»æ•£åŒ– (Coordinate Compression) ---
    # èº«é«˜æ•°å€¼èŒƒå›´å¾ˆå¤§ (1e9)ï¼Œä¸èƒ½ç›´æ¥ä½œä¸ºæ•°ç»„ä¸‹æ ‡ã€‚
    # ä½† N åªæœ‰ 1e5ï¼Œæ‰€ä»¥å°†å…¶æ˜ å°„åˆ° [0, M-1] çš„æ’å (Rank)ã€‚
    vals = sorted(list(set(h)))
    rank_map = {v: i for i, v in enumerate(vals)}
    M = len(vals)

    # --- 2. å®šä¹‰æ ‘çŠ¶æ•°ç»„ (Fenwick Tree) ---
    # bitL: ç”¨äºæŸ¥è¯¢å€¼åŸŸ [0, val - D - 1] å†…çš„æœ€å¤§å±‚æ•°
    # bitR: ç”¨äºæŸ¥è¯¢å€¼åŸŸ [val + D + 1, max_val] å†…çš„æœ€å¤§å±‚æ•°
    # æ•°ç»„å¤§å°è®¾ä¸º M + 1 (å› ä¸ºæ ‘çŠ¶æ•°ç»„é€šå¸¸ä½¿ç”¨ 1-based ç´¢å¼•)
    bitL = [0] * (M + 1)
    bitR = [0] * (M + 1)

    # å•ç‚¹æ›´æ–°ï¼šå°† idx ä½ç½®çš„å€¼æ›´æ–°ä¸º valï¼ˆå–æœ€å¤§å€¼ï¼‰
    def bit_update(bit, idx, val):
        limit = len(bit)
        while idx < limit:
            if val > bit[idx]:
                bit[idx] = val
            idx += idx & (-idx)

    # å‰ç¼€æŸ¥è¯¢ï¼šæŸ¥è¯¢ [1, idx] èŒƒå›´å†…çš„æœ€å¤§å€¼
    def bit_query(bit, idx):
        res = 0
        while idx > 0:
            if bit[idx] > res:
                res = bit[idx]
            idx -= idx & (-idx)
        return res

    # --- 3. è®¡ç®—æ¯ä¸ªåŒå­¦çš„å±‚æ•° ---
    # layer_buckets ç”¨äºæ”¶é›†æ¯ä¸€å±‚çš„åŒå­¦èº«é«˜
    # å­—å…¸ç»“æ„ï¼š{å±‚æ•°: [èº«é«˜1, èº«é«˜2, ...]}
    layer_buckets = {}
    max_layer_global = 0

    for val in h:
        r = rank_map[val] # è·å–å½“å‰èº«é«˜çš„ç¦»æ•£åŒ–æ’å (0 ~ M-1)
        
        # --- è®¡ç®—å·¦ä¾§é˜»å¡çš„æœ€å¤§å±‚æ•° ---
        
        # æƒ…å†µ A: è¢«èº«é«˜å¤ªå°çš„äººé˜»å¡ (h_k < val - D)
        # bisect_left æ‰¾åˆ°ç¬¬ä¸€ä¸ª >= val-D çš„ä½ç½®ï¼Œå…¶å·¦ä¾§å³ä¸º < val-D
        idx_small = bisect.bisect_left(vals, val - D)
        # æŸ¥è¯¢ bitL åœ¨èŒƒå›´ [0, idx_small-1] çš„æœ€å¤§å±‚æ•° (å¯¹åº”BITä¸‹æ ‡ idx_small)
        max_L = bit_query(bitL, idx_small)
        
        # æƒ…å†µ B: è¢«èº«é«˜å¤ªå¤§çš„äººé˜»å¡ (h_k > val + D)
        # bisect_right æ‰¾åˆ°ç¬¬ä¸€ä¸ª > val+D çš„ä½ç½®ï¼Œè¯¥ä½ç½®åŠå³ä¾§å³ä¸º > val+D
        idx_large = bisect.bisect_right(vals, val + D)
        
        # åœ¨ bitR ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨åè½¬æ˜ å°„æŠ€å·§ï¼š
        # å®é™…æ’å rank è¶Šå¤§ï¼Œæ˜ å°„åˆ° bitR çš„ä¸‹æ ‡ M - rank è¶Šå°ã€‚
        # è¿™æ ·æŸ¥è¯¢ bitR çš„å‰ç¼€æœ€å¤§å€¼ï¼Œå®é™…ä¸Šå°±æ˜¯æŸ¥è¯¢åŸæ•°ç»„çš„åç¼€æœ€å¤§å€¼ã€‚
        # èŒƒå›´ [idx_large, M-1] æ˜ å°„åˆ° bitR ä¸‹æ ‡ [1, M - idx_large]
        max_R = 0
        if idx_large < M:
            pos_in_bitR = M - idx_large
            max_R = bit_query(bitR, pos_in_bitR)
            
        # å½“å‰åŒå­¦çš„å±‚æ•° = æ‰€æœ‰é˜»å¡è€…ä¸­çš„æœ€å¤§å±‚æ•° + 1
        cur_layer = max(max_L, max_R) + 1
        
        # è®°å½•å…¨å±€æœ€å¤§å±‚æ•°ä»¥ä¾¿åç»­è¾“å‡º
        if cur_layer > max_layer_global:
            max_layer_global = cur_layer
        
        # å°†èº«é«˜æ”¾å…¥å¯¹åº”çš„å±‚æ¡¶ä¸­
        if cur_layer not in layer_buckets:
            layer_buckets[cur_layer] = []
        layer_buckets[cur_layer].append(val)
        
        # --- æ›´æ–°æ ‘çŠ¶æ•°ç»„ ---
        # å°†å½“å‰åŒå­¦çš„ä¿¡æ¯åŠ å…¥ BITï¼Œæˆä¸ºåç»­åŒå­¦å¯èƒ½çš„é˜»å¡è€…
        
        # æ›´æ–° bitL: æ­£å¸¸æ˜ å°„ï¼Œä¸‹æ ‡ä¸º r + 1
        bit_update(bitL, r + 1, cur_layer)
        
        # æ›´æ–° bitR: åè½¬æ˜ å°„ï¼Œä¸‹æ ‡ä¸º M - r
        bit_update(bitR, M - r, cur_layer)

    # --- 4. è¾“å‡ºç»“æœ ---
    # å­—å…¸åºæœ€å°åŸåˆ™ï¼š
    # 1. å¿…é¡»æŒ‰å±‚æ•°ä»å°åˆ°å¤§è¾“å‡º (æ‹“æ‰‘åº)
    # 2. åŒä¸€å±‚å†…äº’ä¸é˜»å¡ï¼ŒæŒ‰èº«é«˜ä»å°åˆ°å¤§è¾“å‡º (è´ªå¿ƒ)
    
    output = []
    for layer in range(1, max_layer_global + 1):
        if layer in layer_buckets:
            # å¯¹è¯¥å±‚çš„æ‰€æœ‰èº«é«˜è¿›è¡Œæ’åº
            members = sorted(layer_buckets[layer])
            for v in members:
                output.append(str(v))
    
    sys.stdout.write('\n'.join(output) + '\n')

if __name__ == '__main__':
    solve()

```





ã€23çº§ éƒ­ç»é˜³ã€‘<mark>çº¿æ®µæ ‘</mark>

æ’é˜Ÿ-é¢˜è§£ï¼Œhttps://www.cnblogs.com/guoshaoyang/p/17824372.html

æ€è·¯ï¼šè¿™é“é¢˜ä¸€ç›´æƒ³ä¸å‡ºæ¥ï¼Œè±†åŒ…ã€deepseekã€Geminiå’ŒGPTä¹Ÿè¢«å¹²è¶´ä¸‹äº†ï¼Œåæ¥åœ¨ ç½‘ä¸Šæœåˆ°äº†åˆ«äººé¢˜è§£çš„é“¾æ¥ï¼Œåº•å±‚æ€è·¯è¿˜æ˜¯ç”¨åˆ°äº†çº¿æ®µæ ‘çš„åŒºé—´æŸ¥è¯¢ä¸å•ç‚¹ä¿®æ”¹æ€§è´¨ï¼Œç”¨å¾—éå¸¸å·§å¦™ï¼Œä¹‹åè¿˜è¦å¤šä½“ä¼šå‚æ‚Ÿä¸€ä¸‹ã€‚

```python
class SegmentTreeNode:
    def __init__(self, start, end, val):
        self.start = start
        self.end = end
        self.val = val
        self.lson = None
        self.rson = None


class SegmentTree:
    def __init__(self, start, end):
        self.root = SegmentTreeNode(start, end, 0)
        self.start = start
        self.end = end

    def modify(self, node, pos, value, start=None, end=None):
        if (start is None):
            start, end = self.start, self.end
        if (node is None):
            node = SegmentTreeNode(start, end, value)
        if (start == end):
            node.val = max(node.val, value)
            return node
        mid = (node.start + node.end) // 2
        if pos <= mid:
            node.lson = self.modify(node.lson, pos, value, start, mid)
        else:
            node.rson = self.modify(node.rson, pos, value, mid + 1, end)
        node.val = max(node.val, value)
        return node

    def query(self, node, qstart, qend):
        if ((node is None) or qstart > node.end or qend < node.start):
            return 0
        if (qstart <= node.start and node.end <= qend):
            return node.val
        ret = max(self.query(node.lson, qstart, qend), self.query(node.rson, qstart, qend))
        return ret


N, D = map(int, input().split())
h = [int(input()) for _ in range(N)]

MAXH = max(h)
layers = SegmentTree(1, MAXH)
members = [[]]
for hi in h:
    current_layer = max(layers.query(layers.root, 1, hi - D - 1), layers.query(layers.root, hi + D + 1, MAXH)) + 1
    if (current_layer >= len(members)):
        members.append([])
    members[current_layer].append(hi)
    layers.modify(layers.root, hi, current_layer)

for layer in members:
    for _ in sorted(layer):
        print(_)
```



ä¸Šé¢ Python ä»£ç æ€è·¯ï¼ˆæ±‚æ¯ä¸ªå…ƒç´ çš„æœ€é•¿é˜»æŒ¡é“¾é•¿åº¦ï¼Œå³å±‚æ•°ï¼‰æ˜¯æ­£ç¡®çš„ï¼Œä½†åœ¨ Python ä¸­ç›´æ¥ä½¿ç”¨åŸºäº**ç±»ï¼ˆClassï¼‰**å’Œ**åŠ¨æ€å¼€ç‚¹**çš„çº¿æ®µæ ‘ä¼šå¯¼è‡´ä¸¥é‡çš„æ€§èƒ½é—®é¢˜ï¼Œä¸»è¦ä½“ç°åœ¨ä»¥ä¸‹å‡ ç‚¹ï¼š

1.  **å†…å­˜ä¸å¯¹è±¡åˆ›å»ºå¼€é”€**ï¼š`SegmentTreeNode` ç±»çš„å®ä¾‹åŒ–å¼€é”€åœ¨ Python ä¸­å¾ˆå¤§ã€‚å½“ $N=10^5$ æ—¶ï¼Œåˆ›å»ºå‡ åä¸‡ä¸ªå¯¹è±¡ä¼šå¯¼è‡´ TLEï¼ˆTime Limit Exceededï¼‰ç”šè‡³ MLEã€‚
2.  **å€¼åŸŸè¿‡å¤§**ï¼šé¢˜ç›®ä¸­ $H_i$ å¯è¾¾ $10^9$ã€‚å¦‚æœä¸è¿›è¡Œ**ç¦»æ•£åŒ–**ï¼Œç›´æ¥åœ¨ $[1, 10^9]$ ä¸Šå»ºæ ‘ï¼Œè™½ç„¶åŠ¨æ€å¼€ç‚¹èƒ½èŠ‚çœç©ºé—´ï¼Œä½†é€’å½’æ·±åº¦ï¼ˆçº¦ 30 å±‚ï¼‰å åŠ  Python çš„å‡½æ•°è°ƒç”¨å¼€é”€ï¼Œé€Ÿåº¦éå¸¸æ…¢ã€‚
3.  **I/O é€Ÿåº¦**ï¼š`input()` å’Œ `print()` åœ¨å¤§é‡æ•°æ®ä¸‹ç”±äº I/O ç¼“å†²é—®é¢˜ä¼šå¾ˆæ…¢ã€‚

**ä¼˜åŒ–æ–¹æ¡ˆ**

ä¸ºäº†é€šè¿‡è¿™é“é¢˜ï¼Œéœ€è¦è¿›è¡Œä»¥ä¸‹ä¼˜åŒ–ï¼š

1.  **ç¦»æ•£åŒ– (Coordinate Compression)**ï¼š
    è™½ç„¶èº«é«˜ $H_i$ å¾ˆå¤§ï¼Œä½†æ€»å…±åªæœ‰ $N$ ä¸ªèº«é«˜ã€‚æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰å‡ºç°è¿‡çš„èº«é«˜æ’åºå»é‡ï¼Œæ˜ å°„åˆ° $0, 1, \dots, m$ çš„å°èŒƒå›´å†…ã€‚è¿™æ ·å°±å¯ä»¥ä½¿ç”¨å›ºå®šå¤§å°çš„æ•°ç»„æ¥ä»£æ›¿åŠ¨æ€æ ‘ã€‚

2.  **æ•°ç»„ç‰ˆçº¿æ®µæ ‘ (Array-based Segment Tree)**ï¼š
    æŠ›å¼ƒ `class` ç»“æ„ï¼Œä½¿ç”¨æ‰å¹³çš„æ•°ç»„ `tree = [0] * (4 * N)` æ¥å­˜å‚¨çº¿æ®µæ ‘ã€‚è¿™èƒ½æå¤§å‡å°‘å†…å­˜å ç”¨å’Œè®¿é—®æ—¶é—´ã€‚

3.  **è¿­ä»£å¼çº¿æ®µæ ‘ (zkwçº¿æ®µæ ‘)**ï¼š
    ä½¿ç”¨éé€’å½’ï¼ˆå¾ªç¯ï¼‰çš„æ–¹å¼å®ç°æŸ¥è¯¢å’Œæ›´æ–°ï¼Œé¿å… Python çš„é€’å½’æ·±åº¦é™åˆ¶å’Œå‡½æ•°è°ƒç”¨å¼€é”€ï¼Œé€Ÿåº¦é€šå¸¸æ¯”é€’å½’å¿«ä¸€å€ä»¥ä¸Šã€‚

4.  **å¿«é€Ÿ I/O**ï¼š
    ä½¿ç”¨ `sys.stdin.read` ä¸€æ¬¡æ€§è¯»å–æ‰€æœ‰è¾“å…¥ã€‚

**ä¼˜åŒ–åçš„ä»£ç **

```python
import sys
import bisect

# è®¾ç½®é€’å½’æ·±åº¦ï¼Œè™½ç„¶ä¸‹é¢çš„å®ç°æ˜¯è¿­ä»£çš„ï¼Œä½†åœ¨æ··åˆè§£æ³•ä¸­æ˜¯ä¸ªå¥½ä¹ æƒ¯
sys.setrecursionlimit(200000)

def solve():
    # 1. å¿«é€Ÿè¾“å…¥
    input = sys.stdin.read
    data = input().split()
    
    iterator = iter(data)
    try:
        N = int(next(iterator))
        D = int(next(iterator))
    except StopIteration:
        return

    h = []
    for _ in range(N):
        h.append(int(next(iterator)))

    # 2. ç¦»æ•£åŒ– (Discretization)
    # å°† 10^9 çš„èº«é«˜æ˜ å°„åˆ° 0..N çš„æ’åä¸Š
    sorted_h = sorted(list(set(h)))
    m = len(sorted_h)
    
    # 3. å»ºç«‹è¿­ä»£å¼çº¿æ®µæ ‘ (Array-based Iterative Segment Tree)
    # æ ‘çš„å¤§å°åªéœ€è¦†ç›–ç¦»æ•£åŒ–åçš„é•¿åº¦ m
    # è¿™é‡Œçš„ size æœ€å¥½æ˜¯ 2 çš„å¹‚æ¬¡æˆ–è€…æ˜¯ m+1ï¼Œæ•°ç»„å¤§å°å¼€ 2*size å³å¯
    size = m + 1
    tree = [0] * (2 * size)

    # å•ç‚¹æ›´æ–°ï¼šå°†ä½ç½® pos çš„å€¼æ›´æ–°ä¸º max(å½“å‰å€¼, val)
    def update(pos, val):
        pos += size  # ç§»åŠ¨åˆ°å¶å­èŠ‚ç‚¹ä½ç½®
        if tree[pos] < val:
            tree[pos] = val
            while pos > 1:
                pos >>= 1  # ç§»åŠ¨åˆ°çˆ¶èŠ‚ç‚¹
                # çˆ¶èŠ‚ç‚¹çš„å€¼æ˜¯ä¸¤ä¸ªå­èŠ‚ç‚¹çš„æœ€å¤§å€¼
                tree[pos] = max(tree[2*pos], tree[2*pos+1])

    # åŒºé—´æŸ¥è¯¢ï¼šæŸ¥è¯¢ [l, r] é—­åŒºé—´å†…çš„æœ€å¤§å€¼
    def query(l, r):
        if l > r:
            return 0
        l += size
        r += size
        res = 0
        while l <= r:
            if l % 2 == 1:  # å·¦ç«¯ç‚¹æ˜¯å³å­èŠ‚ç‚¹ï¼ŒåŒ…å«å®ƒå¹¶å‘å³ç§»
                if tree[l] > res: res = tree[l]
                l += 1
            if r % 2 == 0:  # å³ç«¯ç‚¹æ˜¯å·¦å­èŠ‚ç‚¹ï¼ŒåŒ…å«å®ƒå¹¶å‘å·¦ç§»
                if tree[r] > res: res = tree[r]
                r -= 1
            l >>= 1
            r >>= 1
        return res

    # 4. è®¡ç®—æ¯ä½åŒå­¦çš„å±‚æ•° (Layer)
    # members[k] å­˜å‚¨ç¬¬ k å±‚çš„æ‰€æœ‰èº«é«˜
    members = [] 

    for val in h:
        # æˆ‘ä»¬éœ€è¦æŸ¥è¯¢åŸå€¼åŸŸèŒƒå›´ï¼š(-inf, val - D - 1] å’Œ [val + D + 1, +inf)
        
        # åˆ©ç”¨ bisect åœ¨ç¦»æ•£åŒ–æ•°ç»„ä¸­æ‰¾åˆ°å¯¹åº”çš„æ’åèŒƒå›´
        # limit_low: val - D - 1 åœ¨ sorted_h ä¸­çš„å³è¾¹ç•Œç´¢å¼•
        # bisect_right è¿”å›æ’å…¥ä½ç½®ï¼Œæ’å…¥ä½ç½®å·¦è¾¹çš„å…ƒç´ éƒ½ <= limit_low
        limit_low = val - D - 1
        idx_low = bisect.bisect_right(sorted_h, limit_low) - 1
        
        # limit_high: val + D + 1 åœ¨ sorted_h ä¸­çš„å·¦è¾¹ç•Œç´¢å¼•
        # bisect_left è¿”å›æ’å…¥ä½ç½®ï¼Œè¯¥ä½ç½®åŠå³è¾¹çš„å…ƒç´ éƒ½ >= limit_high
        limit_high = val + D + 1
        idx_high = bisect.bisect_left(sorted_h, limit_high)
        
        # å½“å‰å€¼çš„æ’åï¼ˆç”¨äºæ›´æ–°ï¼‰
        rank_val = bisect.bisect_left(sorted_h, val)

        # æŸ¥è¯¢ä¸¤ä¸ªåŒºé—´çš„æœ€å¤§å±‚æ•°
        # åŒºé—´1: [0, idx_low]
        # åŒºé—´2: [idx_high, m-1]
        max_f = 0
        
        if idx_low >= 0:
            q1 = query(0, idx_low)
            if q1 > max_f: max_f = q1
            
        if idx_high < m:
            q2 = query(idx_high, m - 1)
            if q2 > max_f: max_f = q2
            
        current_layer = max_f + 1
        
        # æ›´æ–°çº¿æ®µæ ‘
        update(rank_val, current_layer)
        
        # å°†è¯¥èº«é«˜åŠ å…¥å¯¹åº”çš„å±‚
        # åŠ¨æ€æ‰©å±• members æ•°ç»„
        if current_layer > len(members):
            for _ in range(current_layer - len(members)):
                members.append([])
        
        members[current_layer - 1].append(val)

    # 5. è¾“å‡ºç»“æœ
    # æ¯ä¸€å±‚å†…éƒ¨æŒ‰å­—å…¸åºæ’åºï¼ˆä»å°åˆ°å¤§ï¼‰ï¼Œå› ä¸ºå±‚å†…äº’ä¸å¹²æ‰°ï¼ˆæˆ–è€…è¯´å·²è¢«åˆ†å±‚é€»è¾‘å¤„ç†ï¼‰
    output = []
    for layer in members:
        layer.sort()
        output.extend(layer)
        
    print('\n'.join(map(str, output)))

if __name__ == '__main__':
    solve()
```

**ä»£ç å…³é”®ç‚¹è§£é‡Šï¼š**

1.  **`bisect` çš„å¦™ç”¨**ï¼š
    åŸé—®é¢˜æ˜¯åŸºäº**æ•°å€¼**çš„èŒƒå›´æŸ¥è¯¢ï¼ˆä¾‹å¦‚ `query(1, h[i] - D - 1)`ï¼‰ï¼Œä½†çº¿æ®µæ ‘æ˜¯åŸºäº**ç¦»æ•£åŒ–åçš„ä¸‹æ ‡**æ„å»ºçš„ã€‚
    *   `bisect_right(sorted_h, val - D - 1)` èƒ½å¤Ÿå¿«é€Ÿæ‰¾åˆ°æ•°å€¼ `val - D - 1` åœ¨æ’åºæ•°ç»„ä¸­å¯¹åº”çš„ä¸‹æ ‡è¾¹ç•Œï¼Œä»è€Œå°†â€œæ•°å€¼åŒºé—´â€è½¬åŒ–ä¸ºâ€œä¸‹æ ‡åŒºé—´â€ `[0, idx_low]`ã€‚
    *   è¿™æ ·æˆ‘ä»¬æ—¢ä¿ç•™äº†æ•°å€¼çš„å¤§å°å…³ç³»ï¼ˆ$D$ çš„é™åˆ¶ï¼‰ï¼Œåˆäº«å—äº†å°èŒƒå›´ä¸‹æ ‡å¸¦æ¥çš„çº¿æ®µæ ‘æ•ˆç‡ã€‚

2.  **æ‰å¹³åŒ–ä¸ä½è¿ç®—**ï¼š
    `tree` æ•°ç»„çš„å¤§å°ä»…ä¸º $2 \times (N \text{çš„å»é‡ä¸ªæ•°} + 1)$ã€‚
    *   å¯¹äºèŠ‚ç‚¹ `i`ï¼Œå·¦å­©å­æ˜¯ `2*i`ï¼Œå³å­©å­æ˜¯ `2*i+1`ï¼ˆæˆ–è€…åœ¨ä½è¿ç®—ä¸­ `i<<1` å’Œ `i<<1|1`ï¼‰ã€‚
    *   è¿™ç§å†™æ³•åœ¨ Python ä¸­æ¯”ç±»å¯¹è±¡çš„å±æ€§è®¿é—®å¿«å¾—å¤šã€‚

3.  **é€»è¾‘ä¸€è‡´æ€§**ï¼š
    ä½ çš„è´ªå¿ƒç­–ç•¥ï¼ˆè®¡ç®—å±‚æ•° -> å±‚å†…æ’åºï¼‰æ˜¯å®Œå…¨æ­£ç¡®çš„ã€‚è¿™ä¸ªç®—æ³•æœ¬è´¨ä¸Šæ˜¯è®¡ç®—**æœ€é•¿åé“¾**ï¼ˆæˆ–è€…è¯´åœ¨ç‰¹å®šååºå…³ç³»ä¸‹çš„æ‹“æ‰‘å±‚çº§ï¼‰ï¼ŒåŒä¸€å±‚çš„å…ƒç´ ä¹‹é—´æ²¡æœ‰å¼ºåˆ¶çš„å…ˆåä¾èµ–å…³ç³»ï¼ˆæˆ–è€…ä¾èµ–å…³ç³»å·²è¢«æ‰“ç ´ï¼‰ï¼Œå› æ­¤ä¸ºäº†å­—å…¸åºæœ€å°ï¼Œå±‚å†…åº”å½“ä»å°åˆ°å¤§è¾“å‡ºã€‚



**æ€»ç»“è®°å¿†å£è¯€**

 `bisect.bisect_left` å’Œ `bisect.bisect_right` çš„åŒºåˆ«å’Œç”¨æ³•ã€‚

| å‡½æ•°                 | è¡Œä¸º                       |
| -------------------- | -------------------------- |
| `bisect_left(a, x)`  | è¿”å› **ç¬¬ä¸€ä¸ª â‰¥ x** çš„ä½ç½® |
| `bisect_right(a, x)` | è¿”å› **ç¬¬ä¸€ä¸ª > x** çš„ä½ç½® |

åªè¦è®°ä½è¿™ä¸ªæ ¸å¿ƒè§„åˆ™ï¼Œå°±èƒ½åº”å¯¹æ‰€æœ‰åœºæ™¯ï¼

```python
import bisect

a = [1, 2, 3, 3, 3, 5, 6]

left_index = bisect.bisect_left(a, 3)
right_index = bisect.bisect_right(a, 3)

print("åˆ—è¡¨:", a)
print("bisect_left(a, 3) =", left_index)   # è¾“å‡º: 2
print("bisect_right(a, 3) =", right_index) # è¾“å‡º: 5

"""
æ€»ç»“è®°å¿†å£è¯€: å‡½æ•°	è¡Œä¸º
bisect_left(a, x)	è¿”å› ç¬¬ä¸€ä¸ª â‰¥ x çš„ä½ç½®
bisect_right(a, x)	è¿”å› ç¬¬ä¸€ä¸ª > x çš„ä½ç½®
"""
```







<mark>ä¸‹é¢è¿™ä¸ªä»£ç åœ¨è¿™ç»„æ•°æ®ä¸‹ä¸å¯¹ã€‚ä½†æ˜¯äº¤åˆ°OJä¸Šå±…ç„¶èƒ½è¿‡</mark>ã€‚

```
8 3
7
7
3
6
2
10
11
12
```

ä¼šè¾“å‡º

```
6
7
7
11
12
2
3
10
```



```python
from collections import deque

n, d = map(int, input().split())
h = deque(int(input()) for _ in range(n))

ans = []
while h:
    inlist = []
    # ç”¨é˜Ÿé¦–åˆå§‹åŒ–å½“å‰å—çš„æœ€å°/æœ€å¤§å€¼
    cur_min = cur_max = h[0]

    # è¿™ä¸€è½®å®Œæ•´æ‰«ä¸€éå‰©ä½™åŒå­¦
    for _ in range(len(h)):
        x = h.popleft()

        # èƒ½å¦å¹¶å…¥å½“å‰â€œå¯è‡ªç”±é‡æ’â€çš„é›†åˆï¼š
        # æ¡ä»¶ç­‰ä»·äºå¹¶å…¥åæ•´ä½“ç›´å¾„ <= D
        if abs(x - cur_min) <= d and abs(x - cur_max) <= d:
            inlist.append(x)
        else:
            # æ”¾å›é˜Ÿå°¾ï¼Œä¸‹è½®å†å¤„ç†
            h.append(x)

        # æ— è®ºæ”¶ä¸æ”¶ï¼Œè¿™ä¸€è½®çš„â€œå·²è§å…ƒç´ â€æå€¼éƒ½è¦æ›´æ–°
        # ï¼ˆå…³é”®ï¼ä¿æŒä¸åŸ AC æ€è·¯ä¸€è‡´ï¼‰
        if x < cur_min: cur_min = x
        if x > cur_max: cur_max = x
        if cur_max - cur_min > 2*d:
            break

    # è¿™ä¸€è½®æ”¶é›†åˆ°çš„é›†åˆå†…éƒ¨å¯ä»¥ä»»æ„æ’åºï¼Œå–æœ€å°å­—å…¸åº=>å‡åº
    inlist.sort()
    ans.extend(inlist)

print(*ans, sep="\n")

```

**ä¸å˜é‡ 1ï¼š** è‹¥ä¸¤äººèº«é«˜å·® > Dï¼Œåˆ™ä»–ä»¬çš„ç›¸å¯¹å…ˆåæ¬¡åº**æ°¸è¿œæ— æ³•äº’æ¢**ï¼ˆå“ªæ€•ä¸­é—´äººå†å¤šï¼Œæƒ³è¦æ¢åºå¿…ç„¶è¦ç›¸é‚»ä¸€æ¬¡ï¼Œè€Œé‚£æ¬¡ä¸å…è®¸äº¤æ¢ï¼‰ã€‚

**ä¸å˜é‡ 2ï¼š** å¯¹äºä»»æ„é›†åˆ Sï¼Œè‹¥ maxâ¡(S)âˆ’minâ¡(S)â‰¤Dï¼Œåˆ™ S å†…ä»»æ„ä¸¤äººéƒ½å¯ç›¸é‚»äº¤æ¢ï¼Œå› è€Œ**é›†åˆå†…éƒ¨å¯ä»»æ„é‡æ’**ã€‚

æœ¬ç®—æ³•æ¯ä¸€è½®ä»é˜Ÿé¦–å€¼å‡ºå‘ï¼Œ**å°½å¯èƒ½æ‰©å¼ ä¸€ä¸ªâ€œç›´å¾„ â‰¤ Dâ€çš„é›†åˆ**ï¼ˆ`inlist`ï¼‰ã€‚

- å¯¹äºè¢«æ‹’çš„å…ƒç´  yï¼šæ­¤æ—¶å·²æ”¶é›†åˆæœ‰æŸä¸ªå…ƒç´  x ä½¿ âˆ£xâˆ’yâˆ£>Dã€‚äºæ˜¯ y **è¿‡ä¸å»**æ•´ä¸ªå·²æ”¶é›†åˆï¼Œå¿…ç„¶åœ¨æœ€ç»ˆç­”æ¡ˆä¸­æ’åœ¨å®ƒä»¬ä¹‹åâ€”â€”æŠŠ y æ—‹åˆ°é˜Ÿå°¾ï¼Œæ­£æ˜¯â€œå»¶åå¤„ç†â€ã€‚
- å¯¹äºè¢«æ”¶çš„å…ƒç´ ï¼Œå› é›†åˆç›´å¾„ â‰¤ Dï¼Œå®ƒä¸é›†åˆå†…æ‰€æœ‰äººéƒ½èƒ½ä¸¤ä¸¤äº¤æ¢ï¼Œ**å¯è¢«æ”¾åˆ°å‰ç¼€çš„ä»»æ„ä½ç½®**ï¼›å–å‡åºå³å¯å¾—åˆ°è¯¥è½®èƒ½æ”¾åˆ°æœ€å‰çš„ä¸€æ®µçš„æœ€å°å­—å…¸åºã€‚

å®Œæˆä¸€è½®åï¼Œå‰©ä½™å…ƒç´ é‡å¤åŒæ ·è¿‡ç¨‹ï¼›ç”±äºæ‰€æœ‰â€œè¿‡ä¸å»â€çš„äººéƒ½è¢«å»¶åï¼Œæœ€ç»ˆå¾—åˆ°çš„æ•´ä½“åºåˆ—æ˜¯**æ»¡è¶³æ‰€æœ‰â€œä¸å¯é€†å¯¹â€ï¼ˆå·®>Dï¼‰é¡ºåºçº¦æŸä¸‹çš„æœ€å°å­—å…¸åº**ã€‚



ã€æ—å®¶å« 25ç‰©ç†å­¦é™¢ã€‘æ€è·¯ï¼šæ¯ä¸€æ¬¡å¾ªç¯ä¸­ï¼Œä»å‰å¾€åæ‰¾åˆ°æ‰€æœ‰å¯ä»¥ä¸€è·¯ç§»åˆ°æœ€å‰é¢çš„äººï¼Œè¿™äº›äººéƒ½å¯ä»¥ç§»åˆ°æœ€å‰é¢ï¼Œå¹¶ä¸”ä»–ä»¬ä¹‹é—´ä¹Ÿå¯ä»¥äº’ç›¸ä»»æ„äº¤æ¢ï¼Œå¦‚æ­¤å¾ªç¯å¾€å¤å³å¯å®Œæˆã€‚è¿™ä¸ªæ–¹æ³•çš„æœ€å·®æ—¶é—´å¤æ‚åº¦æ˜¯$O(n^2)$ï¼Œ$n=10^5$çš„æ•°æ®é‡åº”è¯¥æ˜¯è¿‡ä¸äº†çš„ï¼Œä½†æ˜¯ç”±äºæ•°æ®æ¯”è¾ƒå¼±ï¼Œæ²¡æƒ³åˆ°ç«Ÿç„¶è¿‡äº†

```python
n, d = map(int, input().split())
h = []
for i in range(n):
    h.append(int(input()))

origin = h
while origin:
    m = 1000000000
    M = 0
    new = []
    out = []
    for x in origin:
        if x > m + d or x < M - d:
            new.append(x)
        else:
            out.append(x)
        m = min(m, x)
        M = max(M, x)
    out.sort()
    for x in out:
        print(x)
    origin = new
```



ã€å¾å‰ 25 ç‰©ç†å­¦é™¢ã€‘æ€è·¯ï¼šè´ªå¿ƒï¼šå­—å…¸åºæœ€å°å¿…è¦ç¬¬ä¸€ä½ä¸Šæœ€å°ï¼›åŒæ—¶æ³¨æ„åˆ°æœ‰ç±»ä¼¼å›¾çš„â€œè”é€šâ€æ€§è´¨â€”â€”ä¸æœ€é«˜mxå’Œæœ€ä½mnè·ç¦»éƒ½ä¸è¶…è¿‡dçš„åŒå­¦å¯ä»¥ç§»åˆ°æœ€å‰é¢â€”â€”å°†è¿™äº›äººæ”¾å…¥tmpæ•°ç»„ï¼Œè¿›è¡Œsortæ’åºã€‚
æ¯æ¬¡éœ€è¦æŠŠæ”¾å…¥tmpæ•°ç»„çš„äººä»å¾…é€‰åˆ—è¡¨ä¸­å»é™¤ï¼Œç”¨é“¾è¡¨å¯ä»¥å®ç°ï¼Œå»é™¤åªéœ€æŠŠiçš„preè¿åˆ°içš„nextä¸Šå³å¯ã€‚
å­¦ä¹ äº†åŒå­¦çš„ä¼˜åŒ–æƒ³æ³•ä»¥åï¼Œå¯ä»¥æŠŠæ¯æ¬¡æ›´æ–°çš„tmpæ•°ç»„æŒ‰æŒ‡æ ‡å­˜å‚¨ï¼Œä»å‰å¾€åä¾æ¬¡è¡¨ç¤ºæ¯ä¸ªç­‰ä»·ç±»ï¼Œmx,mnæ•°ç»„å­˜å‚¨æ¯ä¸ªç­‰ä»·ç±»çš„æœ€å¤§å€¼æœ€å°å€¼ã€‚è¿™æ ·å°±å¯ä»¥ä¸€æ¬¡éå†æ•´ä¸ªæ•°ç»„ï¼Œæ‰¾æ¯ä¸ªå…ƒç´ æ‰€å±çš„ç­‰ä»·ç±»

é“¾è¡¨ä¼˜åŒ–æ”¹è¿›äº†OOPå†™æ³•

```python
class Node:
    def __init__(self, value, idx):
        self.value = value
        self.pre = idx - 1
        self.next = idx + 1

class LinkedList:
    def __init__(self, n):
        self.nodes = []
        #h = list(map(int, input().split()))
        for i in range(n):
            val = int(input())
            self.nodes.append(Node(val, i))
        self.start = 0
        self.tail = n

    def remove(self, idx):
        node = self.nodes[idx]
        if idx == self.start:
            self.start = node.next
        else:
            self.nodes[node.pre].next = node.next
            if node.next == self.tail:
                self.tail = idx
            else:
                self.nodes[node.next].pre = node.pre

    def solve(self, d):
        ans = []
        while self.start != self.tail:
            tmp = []
            i = self.start
            mn = mx = self.nodes[i].value

            while i != self.tail:
                x = self.nodes[i].value
                nxt = self.nodes[i].next
                if mx - d <= x <= mn + d:
                    tmp.append(x)
                    self.remove(i)

                mn = min(mn, x)
                mx = max(mx, x)
                if mx - mn > 2 * d:
                    break
                i = nxt

            ans.extend(sorted(tmp))

        return ans

# main
n, d = map(int, input().split())
q = LinkedList(n)
result = q.solve(d)

print(*result, sep='\n')
```




