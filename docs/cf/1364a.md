# 1364A. XXXXX

brute force/data structures/number theory/two pointers, 1200, https://codeforces.com/problemset/problem/1364/A

Ehab loves number theory, but for some reason he hates the number ğ‘¥. Given an array ğ‘, find the length of its longest subarray such that the sum of its elements **isn't** divisible by ğ‘¥, or determine that such subarray doesn't exist.

An array ğ‘ is a subarray of an array ğ‘ if ğ‘ can be obtained from ğ‘ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

**Input**

The first line contains an integer ğ‘¡ (1â‰¤ğ‘¡â‰¤5) â€” the number of test cases you need to solve. The description of the test cases follows.

The first line of each test case contains 2 integers ğ‘› and ğ‘¥ (1â‰¤ğ‘›â‰¤10^5^, 1â‰¤ğ‘¥â‰¤10^4^) â€” the number of elements in the array ğ‘ and the number that Ehab hates.

The second line contains ğ‘› space-separated integers $ğ‘_1, ğ‘_2, â€¦â€¦, ğ‘_ğ‘› (0â‰¤ğ‘_ğ‘–â‰¤10^4)$ â€” the elements of the array ğ‘.

**Output**

For each testcase, print the length of the longest subarray whose sum isn't divisible by ğ‘¥. If there's no such subarray, print âˆ’1.

Example

input

```
3
3 3
1 2 3
3 4
1 2 3
2 2
0 6
```

output

```
2
3
-1
```

Note

In the first test case, the subarray \[2,3\] has sum of elements 5, which isn't divisible by 3.

In the second test case, the sum of elements of the whole array is 6, which isn't divisible by 4.

In the third test case, all subarrays have an even sum, so the answer is âˆ’1.



æ•°é™¢-èƒ¡ç¿è¯š è¯æ˜ï¼šå¦‚æœæ‰€æœ‰æ•°çš„å’Œä¸æ˜¯xçš„å€æ•°åˆ™ä¸ç”¨å»ã€‚ç°åœ¨è®¾æ‰€æœ‰å’Œæ˜¯xå€æ•°ï¼Œå¦‚æœå¤´å°¾å„å»ä¸€æ®µï¼Œè®¾è¿™ä¸¤æ®µçš„å’Œåˆ†åˆ«ä¸ºA, Bã€‚Aå’ŒBä¸€å®šè‡³å°‘æœ‰ä¸€ä¸ªä¸æ˜¯xå€æ•°ï¼Œé‚£ä¹ˆå»ä¸€å¤´ï¼ˆä¸æ˜¯xå€æ•°çš„é‚£å¤´ï¼‰å°±å¤Ÿäº†ã€‚



```python
from itertools import accumulate

def prefix_sum(nums):
    # prefix = []
    # total = 0
    # for num in nums:
    #     total += num
    #     prefix.append(total)
    # return prefix
    return list(accumulate(nums))

def suffix_sum(nums):
    # suffix = []
    # total = 0
    # # é¦–å…ˆå°†åˆ—è¡¨åè½¬
    # reversed_nums = nums[::-1]
    # for num in reversed_nums:
    #     total += num
    #     suffix.append(total)
    # # å°†ç»“æœåè½¬å›æ¥
    # suffix.reverse()
    # return suffix
    return list(accumulate(reversed(nums)))[::-1]


t = int(input())
for _ in range(t):
    N, x = map(int, input().split())
    a = [int(i) for i in input().split()]
    aprefix_sum = prefix_sum(a)
    asuffix_sum = suffix_sum(a)

    left = 0
    right = N - 1
    if right == 0:
        if a[0] % x != 0:
            print(1)
        else:
            print(-1)
        continue

    leftmax = 0
    rightmax = 0
    while left != right:
        total = asuffix_sum[left]
        if total % x != 0:
            leftmax = right - left + 1
            break
        else:
            left += 1

    left = 0
    right = N - 1
    while left != right:
        total = aprefix_sum[right]
        if total % x != 0:
            rightmax = right - left + 1
            break
        else:
            right -= 1

    if leftmax == 0 and rightmax == 0:
        print(-1)
    else:
        print(max(leftmax, rightmax))
```



```python
for _ in range(int(input())):
    a, b = map(int, input().split())
    s = -1
    A = list(map(lambda x: int(x) % b, input().split()))
    if sum(A) % b:
        print(a)
        continue
    for i in range(a//2+1):
        if A[i] or A[~i]:
            s = a-i-1
            break
    print(s)
```



Pypy3 å¯ä»¥ACã€‚ä½¿ç”¨tree segmentï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(n*logn)

```python
# CF 1364A
 
# def prefix_sum(nums):
#     prefix = []
#     total = 0
#     for num in nums:
#         total += num
#         prefix.append(total)
#     return prefix
 
# def suffix_sum(nums):
#     suffix = []
#     total = 0
#     # é¦–å…ˆå°†åˆ—è¡¨åè½¬
#     reversed_nums = nums[::-1]
#     for num in reversed_nums:
#         total += num
#         suffix.append(total)
#     # å°†ç»“æœåè½¬å›æ¥
#     suffix.reverse()
#     return suffix
 
 
t = int(input())
ans = []
for _ in range(t):
    n, x = map(int, input().split())
    a = [int(i) for i in input().split()]


# Segment tree | Efficient implementation
# https://www.geeksforgeeks.org/segment-tree-efficient-implementation/

    # Max size of tree 
    tree = [0] * (2 * n); 

    def build(arr) : 

        # insert leaf nodes in tree 
        for i in range(n) : 
            tree[n + i] = arr[i]; 
        
        # build the tree by calculating parents 
        for i in range(n - 1, 0, -1) : 
            tree[i] = tree[i << 1] + tree[i << 1 | 1]; 

    # function to update a tree node 
    def updateTreeNode(p, value) : 
        
        # set value at position p 
        tree[p + n] = value; 
        p = p + n; 
        
        # move upward and update parents 
        i = p; 
        
        while i > 1 : 
            
            tree[i >> 1] = tree[i] + tree[i ^ 1]; 
            i >>= 1; 

    # function to get sum on interval [l, r) 
    def query(l, r) : 

        res = 0; 
        
        # loop to find the sum in the range 
        l += n; 
        r += n; 
        
        while l < r : 
        
            if (l & 1) : 
                res += tree[l]; 
                l += 1
        
            if (r & 1) : 
                r -= 1; 
                res += tree[r]; 
                
            l >>= 1; 
            r >>= 1
        
        return res; 
    #aprefix_sum = prefix_sum(a)
    #asuffix_sum = suffix_sum(a)
 
    build([i%x for i in a]);
    
    left = 0
    right = n - 1
    if right == 0:
        if a[0] % x !=0:
            print(1)
        else:
            print(-1)
        continue
 
    leftmax = 0
    rightmax = 0
    while left != right:
        #total = asuffix_sum[left]
        total = query(left, right+1)
        if total % x != 0:
            leftmax = right - left + 1
            break
        else:
            left += 1
 
    left = 0
    right = n - 1
    while left != right:
        #total = aprefix_sum[right]
        total = query(left, right+1)
        if total % x != 0:
            rightmax = right - left + 1
            break
        else:
            right -= 1
    
    if leftmax == 0 and rightmax == 0:
        #print(-1)
        ans.append(-1)
    else:
        #print(max(leftmax, rightmax))
        ans.append(max(leftmax, rightmax))

print('\n'.join(map(str,ans)))
```



å¦‚æœç”¨sumæ±‚å’Œï¼ŒO(n^2)ï¼Œpypy3ä¹Ÿä¼šåœ¨test3 è¶…æ—¶ã€‚




