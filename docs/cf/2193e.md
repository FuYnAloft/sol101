# M2193E. Product Queries

dp, math, number theory, bfs, seive https://codeforces.com/contest/2193/problem/E

Today, Sabyrzhan was called to the board with an array ğ‘ of length ğ‘› and was assigned an officer's task â€” to answer ğ‘› questions.

In the ğ‘–-th question, it is required to determine the minimum number of elements from the array that need to be selected from the board (it is allowed to use the same element multiple times) so that their product is exactly equal to ğ‘–, or to report that it is impossible to achieve such a product.

Note that at least one element must be selected.

**Input**

Each test consists of several test cases. The first line contains one integer ğ‘¡ (1â‰¤ğ‘¡â‰¤104) â€” the number of test cases. The description of the test cases follows.

The first line of each test case contains one integer ğ‘› (1â‰¤ğ‘›â‰¤3â‹…105).

The second line of each test case contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤ğ‘›).

It is guaranteed that the sum of the values of ğ‘› across all test cases does not exceed 3â‹…105.

**Output**

For the ğ‘–-th question, output one integer â€” the minimum number of elements from the array required to obtain a product equal to ğ‘–, or âˆ’1 if it is impossible to achieve such a product.

Example

input

```
6
8
3 2 2 3 7 3 6 7
5
1 2 3 4 5
3
1 1 1
10
2 1 2 1 3 5 5 7 7 7
4
1 1 2 2
1
1
```

output

```
-1 1 1 2 -1 1 1 3
1 1 1 1 1
1 -1 -1
1 1 1 2 1 2 1 3 2 2
1 1 -1 2
1
```

Note

Consider the first test case. The products can be obtained as follows: 

- 1 cannot be obtained. 
- 2 can be obtained by selecting ğ‘2. 
- 3 can be obtained by selecting ğ‘1. 
- 4 can be obtained by selecting ğ‘2 twice. 
- 5 cannot be obtained. 
- 6 can be obtained by selecting ğ‘7. 
- 7 can be obtained by selecting ğ‘5. 
- 8 can be obtained by selecting ğ‘2 three times.



ã€é©¬é“‰é’¦25åŒ–é™¢ã€‘dpã€‚æ³¨æ„æ¥æ”¶æ•°æ®ç”¨listï¼Œå¦‚æœç”¨setä¼šåœ¨ç¬¬24ä¸ªæ•°æ®è¶…æ—¶ã€‚

```python
def sol():
    f = 10000000
    n = int(input())
    se = list(map(int, input().split()))

    res = [f] * (n + 1)
    for i in se:
        res[i] = 1

    for i in range(2, n + 1):
        if res[i] == f:
            continue
        for j in range(i, n // i + 1):
            if res[j] == f:
                continue
            if res[i * j] > res[i] + res[j]:
                res[i * j] = res[i] + res[j]

    del res[0]
    for i in range(n):
        if res[i] == f:
            res[i] = -1

    print(*res)

for _ in range(int(input())):
    sol()
```



è¿™ä¸ªé—®é¢˜å¯ä»¥é€šè¿‡**å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS)** ç»“åˆ **ç­›æ³• (Sieve-like approach)** çš„æ€æƒ³æ¥é«˜æ•ˆè§£å†³ã€‚

**ç®—æ³•æ€è·¯**

1.  **æœ€çŸ­è·¯é—®é¢˜è½¬æ¢**ï¼š
    æˆ‘ä»¬å°†äº§å“ $i$ ($1 \le i \le n$) çœ‹ä½œå›¾ä¸­çš„èŠ‚ç‚¹ã€‚å¦‚æœæˆ‘ä»¬èƒ½é€šè¿‡è‹¥å¹²ä¸ªæ•°ç»„å…ƒç´  $a_j$ çš„ä¹˜ç§¯å¾—åˆ° $i$ï¼Œé‚£ä¹ˆæˆ‘ä»¬æƒ³è¦æ‰¾åˆ°æ‰€éœ€å…ƒç´ ä¸ªæ•°çš„æœ€å°å€¼ã€‚è¿™æœ¬è´¨ä¸Šæ˜¯åœ¨ä¸€ä¸ªéšå«å›¾ä¸­å¯»æ‰¾ä»â€œç©ºç§¯â€ï¼ˆå³æ•°å€¼1ï¼‰åˆ°å„ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚ç”±äºæ¯é€‰æ‹©ä¸€ä¸ªå…ƒç´ æ­¥æ•°åŠ 1ï¼ˆè¾¹æƒä¸º1ï¼‰ï¼ŒBFS æ˜¯æœ€é€‚åˆçš„ã€‚

2.  **BFS çŠ¶æ€ä¸è½¬ç§»**ï¼š
    -   **åˆå§‹çŠ¶æ€**ï¼šæ•°ç»„ä¸­å­˜åœ¨çš„æ¯ä¸€ä¸ªå”¯ä¸€æ•°å­— $x$ï¼ˆä¸” $1 < x \le n$ï¼‰å…¶æ­¥æ•°ä¸º 1ã€‚å°†å®ƒä»¬åŠ å…¥ BFS é˜Ÿåˆ—ã€‚
    -   **è½¬ç§»**ï¼šä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªå·²è¾¾åˆ°çš„æ•°å€¼ $u$ï¼Œå°è¯•å°†å…¶ä¸æ•°ç»„ä¸­çš„å”¯ä¸€å…ƒç´  $v$ ç›¸ä¹˜ã€‚å¦‚æœ $u \times v \le n$ ä¸” $u \times v$ ä¹‹å‰æœªè¢«è®¿é—®è¿‡ï¼Œåˆ™æ›´æ–°å…¶æ­¥æ•°ä¸º `dist[u] + 1` å¹¶åŠ å…¥é˜Ÿåˆ—ã€‚
    -   **ç‰¹æ®Šå¤„ç† 1**ï¼šå¦‚æœæ•°ç»„ä¸­åŒ…å«æ•°å­— `1`ï¼Œåˆ™è¾¾åˆ°ä¹˜ç§¯ `1` çš„æœ€å°æ¬¡æ•°ä¸º 1ã€‚ç”±äºä¹˜ä»¥ 1 ä¸ä¼šæ”¹å˜æ•°å€¼ä½†ä¼šå¢åŠ æ¬¡æ•°ï¼Œå› æ­¤å¯¹äº $i > 1$ çš„æƒ…å†µï¼Œä½¿ç”¨ 1 æ°¸è¿œä¸æ˜¯æœ€ä¼˜çš„ï¼Œæˆ‘ä»¬åªéœ€åœ¨æœ€åå•ç‹¬å¤„ç† `dist[1]`ã€‚

3.  **å¤æ‚åº¦åˆ†æ (ç­›æ³•æ•ˆç‡)**ï¼š
    -   å¯¹äºæ¯ä¸ªä»é˜Ÿåˆ—ä¸­å–å‡ºçš„ $u$ï¼Œæˆ‘ä»¬éå†å”¯ä¸€çš„å…ƒç´ åˆ—è¡¨ $S$ã€‚å¦‚æœæˆ‘ä»¬å°† $S$ æ’åºï¼Œå½“ $u \times v > n$ æ—¶å³å¯åœæ­¢ã€‚
    -   æ€»çš„è®¡ç®—é‡ç±»ä¼¼äºåŸƒæ°ç­›æ³•ï¼šå¯¹äºæ¯ä¸ªæ•° $u$ï¼Œæˆ‘ä»¬æ‰§è¡Œçš„ä¹˜æ³•æ¬¡æ•°æœ€å¤šä¸º $n/u$ã€‚
    -   æ•´ä½“æ—¶é—´å¤æ‚åº¦ä¸º $O(\sum n \ln n)$ã€‚å¯¹äº $n = 3 \cdot 10^5$ï¼Œè¿™ä¸ªæ•°å€¼å¤§çº¦æ˜¯ $4 \cdot 10^6$ï¼Œåœ¨ Python ä¸­é€šè¿‡åˆç†ä¼˜åŒ–å¯ä»¥åœ¨ 3 ç§’å†…è¿è¡Œã€‚

**Python ä»£ç å®ç°**

```python
import sys
from itertools import islice

def solve():
    # ä½¿ç”¨å¿«é€Ÿè¯»å–æ–¹å¼å¤„ç†å¤§é‡æ•°æ®
    input_data = sys.stdin.read().split()
    if not input_data:
        return
    
    it = iter(input_data)
    t_str = next(it, None)
    if t_str is None:
        return
    t = int(t_str)
    
    final_output = []
    
    for _ in range(t):
        n_str = next(it, None)
        if n_str is None:
            break
        n = int(n_str)
        
        # è¯»å–å½“å‰æµ‹è¯•ç”¨ä¾‹çš„æ•°ç»„ a
        a = list(map(int, islice(it, n)))
        
        # é¢„å¤„ç†ï¼šæå–å¤§äº1çš„å”¯ä¸€å…ƒç´ ï¼Œå¹¶è®°å½•æ˜¯å¦æœ‰1
        s_set = set()
        has_one = False
        for x in a:
            if x == 1:
                has_one = True
            elif x <= n:
                s_set.add(x)
        
        # dist[i] å­˜å‚¨å¾—åˆ°ä¹˜ç§¯ i æ‰€éœ€çš„æœ€å°‘å…ƒç´ ä¸ªæ•°ï¼Œ-1 è¡¨ç¤ºä¸å¯è¾¾
        dist = [-1] * (n + 1)
        # å°†å”¯ä¸€å…ƒç´ æ’åºä»¥ä¼˜åŒ– BFS ä¸­çš„ä¹˜æ³•åˆ¤æ–­ï¼ˆç­›æ³•æ ¸å¿ƒï¼‰
        s_list = sorted(list(s_set))
        queue = []
        
        # BFS ç¬¬ä¸€å±‚ï¼šæ•°ç»„ä¸­ç›´æ¥å­˜åœ¨çš„å…ƒç´ ï¼Œè·ç¦»ä¸º1
        for x in s_list:
            dist[x] = 1
            queue.append(x)
        
        # æ‰§è¡Œ BFS
        head = 0
        while head < len(queue):
            u = queue[head]
            head += 1
            
            d_next = dist[u] + 1
            for v in s_list:
                target = u * v
                # å¦‚æœä¹˜ç§¯è¶…è¿‡ nï¼Œåç»­çš„ v ä¼šæ›´å¤§ï¼Œç›´æ¥ä¸­æ–­
                if target > n:
                    break
                # å¦‚æœè¯¥ä¹˜ç§¯å°šæœªè¾¾åˆ°ï¼Œåˆ™æ˜¯æœ€çŸ­è·¯å¾„
                if dist[target] == -1:
                    dist[target] = d_next
                    queue.append(target)
        
        # å¦‚æœåŸæ•°ç»„æœ‰ 1ï¼Œåˆ™ä¹˜ç§¯ 1 çš„æœ€å°æ¬¡æ•°ä¸º 1
        if has_one:
            dist[1] = 1
            
        # æ”¶é›†ç»“æœï¼šdist[1] åˆ° dist[n]
        final_output.append(" ".join(map(str, dist[1:])))
    
    # é›†ä¸­è¾“å‡ºï¼Œæé«˜æ•ˆç‡
    sys.stdout.write("\n".join(final_output) + "\n")

if __name__ == '__main__':
    solve()
```

**å…³é”®ç‚¹è§£é‡Šï¼š**

1.  **`target > n` çš„ä¸­æ–­**ï¼šè¿™æ˜¯å…¸å‹çš„ç­›æ³•ä¼˜åŒ–ã€‚å¦‚æœä¸æ’åº `s_list` æˆ–ä¸è¿›è¡Œè¿™ä¸ªåˆ¤æ–­ï¼Œå¤æ‚åº¦ä¼šé€€åŒ–åˆ° $O(n \cdot |S|)$ï¼Œå¯¼è‡´è¶…æ—¶ã€‚
2.  **BFS é˜Ÿåˆ—**ï¼šé€šè¿‡ `head` æŒ‡é’ˆæ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œæ¯”é¢‘ç¹ä½¿ç”¨ `list.pop(0)` è¦å¿«å¾—å¤šï¼ˆåè€…æ˜¯ $O(n)$ å¤æ‚åº¦ï¼‰ã€‚
3.  **å†…å­˜ç®¡ç†**ï¼šä½¿ç”¨ `sys.stdin.read().split()` å’Œ `islice` èƒ½åœ¨å¤„ç†å¤šè¾¾ $3 \cdot 10^5$ ä¸ªæ•´æ•°æ—¶ä¿æŒè¾ƒå¿«çš„é€Ÿåº¦å¹¶æ§åˆ¶å†…å­˜å¼€é”€ã€‚
4.  **ä¹˜ç§¯ä¸º 1 çš„ç‰¹æ®Šæ€§**ï¼šé¢˜ç›®è¦æ±‚è‡³å°‘é€‰ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœæ•°ç»„é‡Œæ²¡ `1`ï¼Œä»»ä½•å¤§äºç­‰äº 1 ä¸ªå…ƒç´ çš„ç§¯æœ€å°ä¹Ÿæ˜¯ $\min(a_i)$ï¼Œå› æ­¤è‹¥ $\min(a_i) > 1$ï¼Œä¹˜ç§¯ `1` æ˜¯æ— æ³•å¾—åˆ°çš„ï¼Œè¾“å‡º `-1` æ˜¯æ­£ç¡®çš„ã€‚






