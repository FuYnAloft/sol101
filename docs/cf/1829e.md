# 1829E. The Lakes

Dfs and similar, dsu, graphs, implementation, 1100,

https://codeforces.com/problemset/problem/1829/E

You are given an ğ‘›Ã—ğ‘š grid ğ‘ of non-negative integers. The value ğ‘ğ‘–,ğ‘— represents the depth of water at the ğ‘–-th row and ğ‘—-th column.

A lake is a set of cells such that:

- each cell in the set has ğ‘ğ‘–,ğ‘—>0, and
- there exists a path between any pair of cells in the lake by going up, down, left, or right a number of times and without stepping on a cell with ğ‘ğ‘–,ğ‘—=0.

The volume of a lake is the sum of depths of all the cells in the lake.

Find the largest volume of a lake in the grid.

**Input**

The first line contains a single integer ğ‘¡ (1â‰¤ğ‘¡â‰¤10^4^) â€” the number of test cases.

The first line of each test case contains two integers ğ‘›,ğ‘š (1â‰¤ğ‘›,ğ‘šâ‰¤1000) â€” the number of rows and columns of the grid, respectively.

Then ğ‘› lines follow each with ğ‘š integers ğ‘ğ‘–,ğ‘— (0â‰¤ğ‘ğ‘–,ğ‘—â‰¤1000) â€” the depth of the water at each cell.

It is guaranteed that the sum of ğ‘›â‹…ğ‘š over all test cases does not exceed 10^6^.

**Output**

For each test case, output a single integer â€” the largest volume of a lake in the grid.

Example

input

```
5
3 3
1 2 0
3 4 0
0 0 5
1 1
0
3 3
0 1 1
1 0 1
1 1 1
5 5
1 1 1 1 1
1 0 0 0 1
1 0 5 0 1
1 0 0 0 1
1 1 1 1 1
5 5
1 1 1 1 1
1 0 0 0 1
1 1 4 0 1
1 0 0 0 1
1 1 1 1 1
```

output

```
10
0
7
16
21
```



2812 ms ACã€‚	å¯ä»¥ä½¿ç”¨ **æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS) æˆ– å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS)** æ¥é«˜æ•ˆåœ°æ‰¾åˆ°è¿é€šçš„æ¹–æ³Šï¼Œå¹¶è®¡ç®—å…¶ä½“ç§¯ã€‚æ€è·¯ï¼š

1. éå†æ•´ä¸ªç½‘æ ¼ï¼Œæ‰¾åˆ° `a[i][j] > 0` çš„èµ·ç‚¹ï¼Œè¯´æ˜è¿™æ˜¯ä¸€ä¸ªæ¹–çš„ä¸€éƒ¨åˆ†ã€‚
2. é‡‡ç”¨ **DFS æˆ– BFS** éå†ä¸å…¶ç›¸è¿çš„æ‰€æœ‰æ°´åŸŸï¼Œè®¡ç®—æ¹–æ³Šçš„ä½“ç§¯ï¼ˆæ‰€æœ‰è¿é€šå•å…ƒçš„ `a[i][j]` ä¹‹å’Œï¼‰ã€‚
3. è®°å½•æ‰€æœ‰æ¹–æ³Šçš„æœ€å¤§ä½“ç§¯ï¼Œæœ€ç»ˆè¾“å‡ºã€‚

ä¼˜åŒ–

- ä½¿ç”¨ `visited` æ•°ç»„ï¼šé¿å…é‡å¤è®¿é—®åŒä¸€ä¸ªæ¹–æ³Šã€‚
- é‡‡ç”¨è¿­ä»£ BFSï¼ˆæ¯”é€’å½’ DFS æ›´èŠ‚çœæ ˆç©ºé—´ï¼‰ã€‚
- æ¯ä¸ªç½‘æ ¼æœ€å¤šè®¿é—®ä¸€æ¬¡ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ **O(n Ã— m)**ï¼Œèƒ½åœ¨ `10^6` çº§åˆ«æ•°æ®ä¸‹é«˜æ•ˆè¿è¡Œã€‚
- ç”¨ **`sys.stdin.read()`** å¿«é€Ÿè¯»å–å¤§è§„æ¨¡è¾“å…¥ï¼Œé¿å… `input()` å¤šæ¬¡è°ƒç”¨å¯¼è‡´çš„æ€§èƒ½é—®é¢˜ã€‚

```python
import sys
from collections import deque

def bfs(grid, visited, x, y, n, m):
    """ ä½¿ç”¨ BFS è®¡ç®—æ¹–æ³Šä½“ç§¯ """
    queue = deque([(x, y)])
    visited[x][y] = True
    volume = 0

    # æ–¹å‘æ•°ç»„ï¼šä¸Šã€ä¸‹ã€å·¦ã€å³
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while queue:
        cx, cy = queue.popleft()
        volume += grid[cx][cy]  # ç´¯åŠ å½“å‰æ¹–æ³Šå•å…ƒçš„æ°´é‡
        
        for dx, dy in directions:
            nx, ny = cx + dx, cy + dy
            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] > 0:
                visited[nx][ny] = True
                queue.append((nx, ny))
    
    return volume

def largest_lake_volume(test_cases):
    results = []
    
    for n, m, grid in test_cases:
        visited = [[False] * m for _ in range(n)]
        max_volume = 0
        
        for i in range(n):
            for j in range(m):
                if grid[i][j] > 0 and not visited[i][j]:
                    max_volume = max(max_volume, bfs(grid, visited, i, j, n, m))
        
        results.append(str(max_volume))
    
    # ç»Ÿä¸€è¾“å‡ºï¼Œæé«˜æ€§èƒ½
    sys.stdout.write("\n".join(results) + "\n")

def main():
    # è¯»å–è¾“å…¥
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    t = int(data[index])
    index += 1
    test_cases = []
    
    for _ in range(t):
        n, m = map(int, data[index:index+2])
        index += 2
        grid = [list(map(int, data[index + i * m: index + (i + 1) * m])) for i in range(n)]
        index += n * m
        test_cases.append((n, m, grid))
    
    largest_lake_volume(test_cases)

if __name__ == "__main__":
    main()
```



![image-20231201025017890](https://raw.githubusercontent.com/GMyhf/img/main/img/202312010250266.png)

```python
from collections import deque

def bfs(x, y):
    cnt = field[x][y]
    field[x][y] = 0
    #queue = [(x, y)]
    queue = deque([(x, y)])

    while queue:
        x, y = queue.pop()

        for k in range(4):
            nx, ny = x + dx[k], y + dy[k]
            if field[nx][ny]:
                cnt += field[nx][ny]
                field[nx][ny] = 0
                queue.append((nx, ny))
    return cnt


t = int(input())
for _ in range(t):
    n, m = map(int, input().split())
    field = [[0 for _ in range(m+2)] for _ in range(n+2)]

    for i in range(1, n+1):
        field[i][1:-1] = list(map(int, input().split()))

    best = 0
    dx = [-1,  0, 0, 1]
    dy = [0, -1, 1, 0]
    for i in range(1, n+1):
        for j in range(1, m+1):
            if field[i][j] != 0:
                best = max(best, bfs(i, j))

    print(best)
```


