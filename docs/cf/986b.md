# 986B. Petr and Permutations

Combinatiorics, math, 1800, https://codeforces.com/problemset/problem/986/B

Petr likes to come up with problems about randomly generated data. This time problem is about random permutation. He decided to generate a random permutation this way: he takes identity permutation of numbers from 1 to ğ‘› and then 3ğ‘› times takes a random pair of different elements and swaps them. Alex envies Petr and tries to imitate him in all kind of things. Alex has also come up with a problem about random permutation. He generates a random permutation just like Petr but swaps elements 7ğ‘›+1 times instead of 3ğ‘› times. Because it is more random, OK?!

You somehow get a test from one of these problems and now you want to know from which one.

**Input**

In the first line of input there is one integer ğ‘› (103â‰¤ğ‘›â‰¤106).

In the second line there are ğ‘› distinct integers between 1 and ğ‘› â€” the permutation of size ğ‘› from the test.

It is guaranteed that all tests except for sample are generated this way: First we choose ğ‘› â€” the size of the permutation. Then we randomly choose a method to generate a permutation â€” the one of Petr or the one of Alex. Then we generate a permutation using chosen method.

**Output**

If the test is generated via Petr's method print "Petr" (without quotes). If the test is generated via Alex's method print "Um_nik" (without quotes).

Example

input

```
5
2 4 5 1 3
```

output

```
Petr
```

Note

Please note that the sample is not a valid test (because of limitations for ğ‘›) and is given only to illustrate input/output format. Your program **still has to print correct answer to this test** to get AC.

Due to randomness of input hacks in this problem are forbidden.



ã€å°¹æ˜¾é½25ç‰©é™¢ã€‘ä»£ç åŸç†ï¼šå¦‚æœä¸€ä¸ªç»è¿‡ $n$ æ¬¡å…ƒç´ äº¤æ¢çš„å…¨æ’åˆ—ç»è¿‡ $m$ æ¬¡å…ƒç´ äº¤æ¢è¿˜åŸï¼Œé‚£ä¹ˆ $m$ å’Œ $n$ çš„å¥‡å¶æ€§ç›¸åŒã€‚ï¼ˆå› ä¸ºäº¤æ¢ä¸€æ¬¡å…ƒç´ æ”¹å˜æ’åˆ—çš„å¥‡å¶æ€§ï¼‰

å…·ä½“æ“ä½œï¼šï¼ˆè§30179é¢˜è§£ï¼Œ2020fall_cs101.openjudge.cn_problems.mdï¼‰
å¯¹äºarræ•°ç»„ä¸­ä¸‹æ ‡ä¸º i-1 çš„å…ƒç´ ï¼Œå¦‚æœå®ƒç­‰äº i ï¼Œè¯´æ˜ä»–å·²ç»åœ¨æ­£ç¡®çš„ä½ç½®ä¸Šäº†ï¼Œå°±å‰å¾€ä¸‹ä¸€ä¸ªå…ƒç´ ï¼›å¦‚æœå®ƒä¸ç­‰äº i ï¼Œå°±å°†ä¸‹æ ‡ä¸º arr[i-1] -1 çš„å…ƒç´ ä¸å®ƒäº¤æ¢ï¼Œè¿™æ ·è®©å®ƒåœ¨è‡ªå·±åº”è¯¥åœ¨çš„ä½ç½®ä¸Šï¼Œé‡å¤ä»¥ä¸Šæ“ä½œï¼Œç›´åˆ°å®ƒç­‰äº i ã€‚

```python
def inversion_count():
    global n
    c = 0
    for i in range(1,n+1):
        while arr[i-1] != i:
            idx = arr[i-1]-1
            arr[idx],arr[i-1] = arr[i-1],arr[idx]
            c = 1-c
    return c
n = int(input())
arr = list(map(int,input().split()))
dic = {0:"Petr",1:"Um_nik"}
print(dic[(inversion_count()+n)%2])

```


