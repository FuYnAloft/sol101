# 1883D. In Love

data structure, greedy, 1500, https://codeforces.com/problemset/problem/1883/D

Initially, you have an empty multiset of segments. You need to process ğ‘ operations of two types:

- \+ ğ‘™ ğ‘Ÿ â€” Add the segment (ğ‘™,ğ‘Ÿ) to the multiset,
- âˆ’ ğ‘™ ğ‘Ÿ â€” Remove **exactly** one segment (ğ‘™,ğ‘Ÿ) from the multiset. It is guaranteed that this segment exists in the multiset.

After each operation, you need to determine if there exists a pair of segments in the multiset that do not intersect. A pair of segments (ğ‘™,ğ‘Ÿ) and (ğ‘,ğ‘) do not intersect if there does not exist a point ğ‘¥ such that ğ‘™â‰¤ğ‘¥â‰¤ğ‘Ÿ and ğ‘â‰¤ğ‘¥â‰¤ğ‘.

**Input**

The first line of each test case contains an integer ğ‘ (1â‰¤ğ‘â‰¤10^5^) â€” the number of operations.

The next ğ‘ lines describe two types of operations. If it is an addition operation, it is given in the format \+ ğ‘™ ğ‘Ÿ. If it is a deletion operation, it is given in the format âˆ’ ğ‘™ ğ‘Ÿ (1â‰¤ğ‘™â‰¤ğ‘Ÿâ‰¤10^9^).

**Output**

After each operation, print "YES" if there exists a pair of segments in the multiset that do not intersect, and "NO" otherwise.

You can print the answer in any case (uppercase or lowercase). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive answers.

Example

input

```
12
+ 1 2
+ 3 4
+ 2 3
+ 2 2
+ 3 4
- 3 4
- 3 4
- 1 2
+ 3 4
- 2 2
- 2 3
- 3 4
```

output

```
NO
YES
YES
YES
YES
YES
NO
NO
YES
NO
NO
NO
```

Note

In the example, after the second, third, fourth, and fifth operations, there exists a pair of segments (1,2)(1,2) and (3,4)(3,4) that do not intersect.

Then we remove exactly one segment (3,4)(3,4), and by that time we had two segments. Therefore, the answer after this operation also exists.



```python
'''
The claim is that if the answer exists, we can take the segment with 
the minimum right boundary and the maximum left boundary 
(let's denote these boundaries as ğ‘Ÿ and ğ‘™). Therefore, if ğ‘Ÿ<ğ‘™
, it is obvious that this pair of segments is suitable for us. 
Otherwise, all pairs of segments intersect because they have common 
points in the range ğ‘™â€¦ğ‘Ÿ.

å…ˆå†™äº†ä¸ªè¶…æ—¶çš„ç®—æ³•ï¼Œç„¶åçœ‹tutorialåŠå…¶ä»–äººå¼•å…¥dict, heapçš„ä»£ç ã€‚
æŒ‰ç…§åŒºé—´å³ç«¯ç‚¹ä»å°åˆ°å¤§æ’åºã€‚ä»å‰å¾€åä¾æ¬¡æšä¸¾æ¯ä¸ªåŒºé—´ã€‚
å‡è®¾å½“å‰éå†åˆ°çš„åŒºé—´ä¸ºç¬¬iä¸ªåŒºé—´ [li, ri]ï¼Œå¦‚æœæœ‰li > edï¼Œ
è¯´æ˜å½“å‰åŒºé—´ä¸å‰é¢æ²¡æœ‰äº¤é›†ã€‚
'''

import sys
import heapq
from collections import defaultdict
input = sys.stdin.readline
 
minH = []
maxH = []
 
ldict = defaultdict(int)
rdict = defaultdict(int)
 
n = int(input())
 
for _ in range(n):
    op, l, r = map(str, input().strip().split())
    l, r = int(l), int(r)
    if op == "+":
        ldict[l] += 1
        rdict[r] += 1
        heapq.heappush(maxH, -l)
        heapq.heappush(minH, r)
    else:
        ldict[l] -= 1
        rdict[r] -= 1
    
    '''
    ä½¿ç”¨ while å¾ªç¯ï¼Œå°†æœ€å¤§å † maxH å’Œæœ€å°å † minH ä¸­å‡ºç°æ¬¡æ•°ä¸º 0 çš„è¾¹ç•Œç§»é™¤ã€‚
    é€šè¿‡æ¯”è¾ƒå †é¡¶å…ƒç´ çš„å‡ºç°æ¬¡æ•°ï¼Œå¦‚æœå‡ºç°æ¬¡æ•°ä¸º 0ï¼Œåˆ™é€šè¿‡ heappop æ–¹æ³•å°†å…¶ä»å †ä¸­ç§»é™¤ã€‚
    '''
    while len(maxH) > 0 >= ldict[-maxH[0]]:
        heapq.heappop(maxH)
    while len(minH) > 0 >= rdict[minH[0]]:
        heapq.heappop(minH)
    
    '''
    åˆ¤æ–­å † maxH å’Œ minH æ˜¯å¦éç©ºï¼Œå¹¶ä¸”æœ€å°å † minH çš„å †é¡¶å…ƒç´ æ˜¯å¦å°äº
    æœ€å¤§å † maxH çš„å †é¡¶å…ƒç´ çš„ç›¸åæ•°ã€‚
    '''
    if len(maxH) > 0 and len(minH) > 0 and minH[0] < -maxH[0]:
        print("Yes")
    else:
        print("No")
```



ã€é©¬é“‰é’¦25åŒ–é™¢ã€‘å‰è¨€ï¼šè¿™ä¸‰é“CF1970é¢˜å¯¹ç®—æ³•çŸ¥è¯†çš„è¦æ±‚å¾ˆä½ï¼Œä½†å¯¹æ•°å­¦çŸ¥è¯†æœ‰ä¸€å®šè¦æ±‚ã€‚
