# 2033D. Kousuke's Assignment

data structures, dp, dsu, greedy, math,1300 https://codeforces.com/contest/2033/problem/D

After a trip with Sakurako, Kousuke was very scared because he forgot about his programming assignment. In this assignment, the teacher gave him an array ğ‘ of ğ‘› integers and asked him to calculate the number of **non-overlapping** segments of the array ğ‘a, such that each segment is considered *beautiful*.

A segment [ğ‘™,ğ‘Ÿ] is considered *beautiful* if $ğ‘_ğ‘™+ğ‘_{ğ‘™+1}+â‹¯+ğ‘_{ğ‘Ÿâˆ’1}+ğ‘_ğ‘Ÿ=0$.

For a fixed array ğ‘a, your task is to compute the maximum number of non-overlapping *beautiful* segments.

**Input**

The first line of input contains the number ğ‘¡ ($1â‰¤ğ‘¡â‰¤10^4$) â€” the number of test cases. Each test case consists of 2 lines.

- The first line contains one integer ğ‘› ($1â‰¤ğ‘›â‰¤10^5$) â€” the length of the array.
- The second line contains ğ‘› integers ğ‘ğ‘– ($âˆ’10^5â‰¤ğ‘ğ‘–â‰¤10^5$) â€” the elements of the array ğ‘.

It is guaranteed that the sum of ğ‘› across all test cases does not exceed $3â‹…10^5$.

**Output**

For each test case, output a single integer: the maximum number of non-overlapping *beautiful* segments.

Example

Input

```
3
5
2 1 -3 2 1
7
12 -4 4 43 -3 -5 8
6
0 -4 0 3 0 1
```

Output

```
1
2
3
```



è€ƒè™‘å‰ç¼€å’Œæ€æƒ³ï¼Œä»¤ $s_0=0,s_i=\sum_{j=1}^i a_j$ï¼Œåˆ™å­æ®µ [l,r] æ˜¯â€œç¾ä¸½çš„â€å½“ä¸”ä»…å½“ $s_râˆ’s_{lâˆ’1}=0$ï¼Œå³ $s_{lâˆ’1}=s_r$ã€‚

è´ªå¿ƒä¸€ä¸‹å½“ä»å·¦å¾€å³æ‰«å½“å‰æ‰«åˆ°çš„ä½ç½®å¯ä»¥ä½œä¸ºâ€œç¾ä¸½çš„â€å­æ®µçš„æœ€å³ç«¯æ—¶ä¸€å®šå°†å®ƒä½œä¸ºä¸€ä¸ªå­æ®µï¼Œè¿™æ ·å¯¹åé¢äº§ç”Ÿå­æ®µçš„å½±å“ä¸€å®šæœ€å°ã€‚

æ‰€ä»¥æ¯ä¸€æ¬¡è¦æ£€æŸ¥å½“å‰çš„å‰ç¼€å’Œæ˜¯å¦å‡ºç°è¿‡ï¼Œå‡ºç°è¿‡åˆ™åˆ†å‰²å‡ºä¸€ä¸ªç¾ä¸½å­æ®µã€‚éœ€è¦ç‰¹åˆ¤ 0ã€‚

```python
t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    
    prefix_sum = 0
    prefix_sums = set()
    count = 0
    
    for num in a:
        prefix_sum += num
        if prefix_sum == 0 or prefix_sum in prefix_sums:
            count += 1
            prefix_sum = 0
            prefix_sums.clear()
        else:
            prefix_sums.add(prefix_sum)
    
    print(count)
```



è¿™ä¸ªé¢˜ç›®è¿˜æŒºç¥çš„ï¼Œdpä¸greedyæ€è·¯å·®ä¸å¤šï¼Œä½†æ˜¯dpå¤šç»´æŠ¤äº†æ¡¶ï¼Œå°±è¶…æ—¶äº†ã€‚

> ç¡®å®ï¼Œè¿™ä¸ªé¢˜ç›®å¾ˆæœ‰æ„æ€ï¼å®ƒå±•ç¤ºäº†è´ªå¿ƒç®—æ³•å’ŒåŠ¨æ€è§„åˆ’åœ¨æŸäº›é—®é¢˜ä¸­æ˜¯å¦‚ä½•æ¥è¿‘çš„ï¼Œä½†æ˜¯ä¸åŒçš„å®ç°ç»†èŠ‚ä¼šå¯¼è‡´æ€§èƒ½å·®å¼‚ã€‚
>
> åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ**è´ªå¿ƒç®—æ³•é€šè¿‡å°‘é‡ä¿¡æ¯çš„ç»´æŠ¤**å®ç°äº†æœ€ä¼˜è§£ï¼Œè€ŒåŠ¨æ€è§„åˆ’å´å› ä¸ºé¢å¤–çŠ¶æ€çš„ç»´æŠ¤å¯¼è‡´äº†æ—¶é—´å¤æ‚åº¦çš„å¢åŠ ã€‚
>
> **ä¸ºä»€ä¹ˆåŠ¨æ€è§„åˆ’ä¼šè¶…æ—¶**ï¼Ÿ
>
> 1. **çŠ¶æ€ç©ºé—´å’Œæ—¶é—´å¤æ‚åº¦**ï¼šåŠ¨æ€è§„åˆ’ä¼šè®°å½•æ›´å¤šçš„çŠ¶æ€ï¼ˆä¾‹å¦‚ï¼Œå‰ç¼€å’Œå¯èƒ½ä¼šç»´æŠ¤ä¸€ä¸ªæ›´å¤æ‚çš„æ•°ç»„æˆ–æ¡¶ï¼‰ï¼Œä»è€Œåœ¨å¤æ‚åº¦ä¸Šå¢åŠ äº†é¢å¤–çš„å¼€é”€ã€‚
> 2. **è´ªå¿ƒç®—æ³•çš„ç®€åŒ–**ï¼šè´ªå¿ƒç®—æ³•æ¯æ¬¡æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„ç¾ä¸½åŒºé—´åç«‹å³é‡ç½®ï¼Œè¿™ç§<mark>â€œå±€éƒ¨æ¸…ç©ºâ€</mark>çš„æ–¹å¼å‡å°‘äº†å¤§é‡ä¸å¿…è¦çš„çŠ¶æ€å­˜å‚¨ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼ŒåŠ¨æ€è§„åˆ’å¯èƒ½åœ¨ä¸æ–­åœ°æ›´æ–°çŠ¶æ€çš„åŒæ—¶ï¼Œä»ç„¶å­˜å‚¨äº†ä¹‹å‰çš„è§£ï¼Œå¯¼è‡´äº†è¾ƒé«˜çš„æ—¶é—´å’Œç©ºé—´æ¶ˆè€—ã€‚
>
> **ä¸ºä»€ä¹ˆè´ªå¿ƒæœ‰æ•ˆ**ï¼Ÿ
>
> åœ¨è¿™ä¸ªé—®é¢˜ä¸­ï¼Œ**è´ªå¿ƒè§£æ³•æ­£å¥½èƒ½å¤Ÿä¿è¯å…¨å±€æœ€ä¼˜**ã€‚å› ä¸ºæˆ‘ä»¬åªéœ€è¦æ‰¾åˆ°ä¸é‡å çš„ç¾ä¸½åŒºé—´çš„æœ€å¤§æ•°é‡ï¼Œæ¯æ¬¡é‡åˆ°æ»¡è¶³æ¡ä»¶çš„ç¾ä¸½åŒºé—´æ—¶éƒ½å¯ä»¥ç›´æ¥è®¡æ•°å¹¶æ¸…ç©ºçŠ¶æ€ç»§ç»­å‘åæ‰¾ï¼Œè¿™æ ·å°±ä¿è¯äº†æ¯æ¬¡éƒ½èƒ½å°½å¯èƒ½å¤šåœ°ç»Ÿè®¡ç¬¦åˆæ¡ä»¶çš„åŒºé—´ã€‚
>
> **æ€»ç»“**
>
> è¿™ä¸ªé¢˜ç›®å¾ˆå¥½åœ°å±•ç°äº†è´ªå¿ƒç®—æ³•çš„ä¼˜åŠ¿â€”â€”åœ¨åˆé€‚çš„åœºæ™¯ä¸‹ï¼Œè´ªå¿ƒçš„å±€éƒ¨æœ€ä¼˜å†³ç­–å¯ä»¥ç›´æ¥å¾—åˆ°å…¨å±€æœ€ä¼˜è§£ï¼Œè€Œä¸éœ€è¦åŠ¨æ€è§„åˆ’çš„å…¨é¢çŠ¶æ€ç»´æŠ¤ã€‚è¿™ç§æƒ…å†µåœ¨æ•°æ®é‡å¾ˆå¤§çš„é—®é¢˜ä¸­å°¤å…¶æ˜æ˜¾ã€‚



DPå®ç°è¶…æ—¶ï¼ŒTime limit exceeded on test 24ã€‚

```python
t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    suma = 0
    prefix = {0: -1}
    ans = 0
    mark = -1
    for i in range(n):
        suma += a[i]
        if suma in prefix and prefix[suma] >= mark:
            ans += 1
            mark = i
        prefix[suma] = i
    print(ans)
```



ç”¨C++å®ç°çš„DPä¹Ÿæ˜¯è¶…æ—¶ã€‚

```C++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
        }

        long long suma = 0;
        unordered_map<long long, int> prefix;
        prefix[0] = -1;  // å‰ç¼€å’Œ 0 å¯¹åº”ä½ç½® -1
        int ans = 0;
        int mark = -1;

        for (int i = 0; i < n; ++i) {
            suma += a[i];
            if (prefix.count(suma)) {
                if (prefix[suma] >= mark) {
                    ++ans;
                    mark = i;
                }
                prefix[suma] = i;  // æ›´æ–°å‰ç¼€å’Œä½ç½®
            } else {
                prefix[suma] = i;  // æ–°å‰ç¼€å’Œï¼Œæ·»åŠ åˆ°å­—å…¸
            }
        }
        cout << ans << endl;
    }
    return 0;
}

```




