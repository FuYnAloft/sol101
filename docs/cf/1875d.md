# 1875D. Jellyfish and Mex

dp, 1600, https://codeforces.com/problemset/problem/1875/D

You are given an array of ğ‘› nonnegative integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›.

Let ğ‘š be a variable that is initialized to 00, Jellyfish will perform the following operation ğ‘› times:

- select an index ğ‘– (1â‰¤ğ‘–â‰¤|ğ‘|) and delete ğ‘ğ‘– from ğ‘.
- add MEX(ğ‘)â€  to ğ‘š.

Now Jellyfish wants to know the minimum possible final value of ğ‘š if he performs all the operations optimally.

â€ â€  The MEX (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. For instance:

- The MEX of \[2,2,1] is 0, because 0 does not belong to the array.
- The MEX of \[3,1,0,1] is 2, because 0 and 1 belong to the array, but 2 does not.
- The MEX of \[0,3,1,2] is 4 because 0, 1, 2, and 3 belong to the array, but 4 does not.

**Input**

Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1â‰¤ğ‘¡â‰¤5000). The description of the test cases follows.

The first line of each test case contains a single integer ğ‘› (1â‰¤ğ‘›â‰¤5000) â€” the size of the array.

The second line of each test case contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (0â‰¤ğ‘ğ‘–â‰¤10^9^) â€” the integers in the array.

It is guaranteed that the sum of ğ‘› over all test cases does not exceed 50005000.

**Output**

For each test case, output a single integer â€” the minimum value of ğ‘š if the operations are performed optimally.

Example

input

```
4
8
5 2 1 0 3 0 4 0
2
1 2
5
1 0 2 114514 0
8
0 1 2 0 1 2 0 3
```

output

```
3
0
2
7
```

Note

In the first test case, we delete elements from ğ‘ in the following order: [5,2,1,0,3,0,4,0]â†’[5,2,0,3,0,4,0]â†’[5,2,0,3,4,0]â†’[5,2,3,4,0]â†’[5,2,3,4]â†’[5,2,4]â†’[2,4]â†’[4]â†’[ ]. The value of ğ‘š will be 1+1+1+0+0+0+0+0=3.



æ˜¾ç„¶ï¼Œé™¤é mexa=0ï¼Œå¦åˆ™ä¸ä¼šåˆ é™¤ >mexa çš„æ•°ã€‚è€Œ mexa=0 æ—¶ä¸å¯¹ç­”æ¡ˆäº§ç”Ÿè´¡çŒ®ï¼Œå› æ­¤ä»»æ„æ—¶åˆ»æˆ‘ä»¬éƒ½å¯ä»¥å¿½ç•¥ a ä¸­ >mexa çš„æ•°ã€‚

é¦–å…ˆè¦åˆ è‚¯å®šæŠŠä¸€ä¸ªæ•°åˆ å®Œå†åˆ ä¸‹ä¸€ä¸ªï¼Œåˆ äº†ä¸€ä¸ªä¹‹åè‚¯å®šæ¥ä¸‹æ¥åˆ æŸä¸ªæ¯”ä»–å°çš„ï¼Œç„¶åå°±å˜æˆäº†å¦‚ä½•é€‰è¿™ä¸€åˆ—é€’é™çš„æ•°æœ€å°åŒ–é‚£ä¸ªå’Œã€‚



è€ƒå¯Ÿé¦–å…ˆè¦åˆ å…‰å“ªä¸ªæ•°ï¼Œä¸å¦¨è®¾ä¸º jï¼ˆj<iï¼‰ã€‚è®¾ j å‡ºç°æ¬¡æ•°ä¸º cnt(j)ã€‚æ˜¾ç„¶ï¼Œå‰ cnt(j)âˆ’1 æ¬¡åˆ é™¤æ—¶ j è¿˜æœªè¢«åˆ å…‰ï¼Œæ­¤æ—¶å¯¹ç­”æ¡ˆè´¡çŒ®ä¸º iï¼›æœ€åä¸€æ¬¡åˆ é™¤æ—¶ j å·²è¢«åˆ å…‰ï¼Œæ­¤æ—¶å¯¹ç­”æ¡ˆè´¡çŒ®ä¸º jã€‚åˆ é™¤ç»“æŸåï¼Œå‰©ä½™çš„æ•°åˆ—æ»¡è¶³ä¿ç•™äº†æ‰€æœ‰ <j çš„æ•°ï¼Œä¸” mexa=jã€‚æ­¤æ—¶ï¼Œæ‰€æœ‰ [j+1,iâˆ’1] çš„æ•°éƒ½å¯ä»¥è¢«å¿½ç•¥ï¼Œé—®é¢˜è½¬åŒ–ä¸º fjã€‚å› æ­¤ï¼Œå¾—åˆ°è½¬ç§»æ–¹ç¨‹ï¼š

$f_i= \begin{cases} 0,&i=0\\ \min\limits_{j<i}\{f_j+(cnt(j)-1)\times i+j\},&i>0 \end{cases}$



dfs

```python
# æŸ¥è¾¾é—»
# https://codeforces.com/problemset/problem/1875/D
from functools import lru_cache
for _ in range(int(input())):
    @lru_cache
    def dfs(m):
        if m == 0:
            return 0
        x = float('inf')
        for i, cnt in enumerate(cnts):
            if move[i]:
                if i >= m:
                    break
                x = min(x, m * cnt - m + i + dfs(i))
        return x

    n = int(input())
    *a, = map(int, input().split())
    cnts = [0] * (n+1)
    
    # å‡ºç°æ¬¡æ•°ç›¸åŒæ—¶æ›´å¤§çš„æ•°ä¸ç”¨è€ƒè™‘
    # 0 0 0 0 0 1 1 1 1 1 2 2 2 2 2åªç”¨è€ƒè™‘0å°±è¡Œ
    move = [True] * (n + 1)
    
    for i in range(n):
        if a[i] <= n:
            cnts[a[i]] += 1

    if cnts[0] <= 0:
        print(0); continue

    mex = 0
    min_before = float('inf')
    while cnts[mex]:
        if cnts[mex] >= min_before: 
            move[mex] = False
        else:
            min_before = cnts[mex]
            
        mex += 1

    print(dfs(mex))
```



dp

```python
inf = float('inf')

T = int(input())
for _ in range(T):
    n = int(input())
    a = list(map(int, input().split()))
    cnt = [0] * (n+1)
    
    # å‡ºç°æ¬¡æ•°ç›¸åŒæ—¶æ›´å¤§çš„æ•°ä¸ç”¨è€ƒè™‘
    # 0 0 0 0 0 1 1 1 1 1 2 2 2 2 2åªç”¨è€ƒè™‘0å°±è¡Œ
    move = [True] * (n + 1)

    dp = [0] + [inf] * n
    for i in range(n):
        if a[i] <= n:
            cnt[a[i]] += 1
    
    if cnt[0] <= 0:
        print(0); continue
    
    mex, min_before = 0, inf

    while cnt[mex]:
        if cnt[mex] >= min_before: 
            move[mex] = False
        else:
            min_before = cnt[mex]    
        mex += 1
        
    for i in range(1, mex+1):
        if move[i]:
            for j in range(i):
                if move[j]:
                    dp[i] = min(dp[i], dp[j] + (cnt[j] - 1) * i + j)
    print(dp[mex])
```


