# 1843D. Apple Tree

Combinatorics, dfs and similar, dp, math, trees, 1200, 

https://codeforces.com/problemset/problem/1843/D

Timofey has an apple tree growing in his garden; it is a rooted tree of ğ‘› vertices with the root in vertex 1 (the vertices are numbered from 1 to ğ‘›). A tree is a connected graph without loops and multiple edges.

This tree is very unusual â€” it grows with its root upwards. However, it's quite normal for programmer's trees.

The apple tree is quite young, so only two apples will grow on it. Apples will grow in certain vertices (these vertices may be the same). After the apples grow, Timofey starts shaking the apple tree until the apples fall. Each time Timofey shakes the apple tree, the following happens to each of the apples:

Let the apple now be at vertex ğ‘¢.

- If a vertex ğ‘¢ has a child, the apple moves to it (if there are several such vertices, the apple can move to any of them).
- Otherwise, the apple falls from the tree.

It can be shown that after a finite time, both apples will fall from the tree.

Timofey has ğ‘ assumptions in which vertices apples can grow. He assumes that apples can grow in vertices ğ‘¥ and ğ‘¦, and wants to know the number of pairs of vertices (ğ‘, ğ‘) from which apples can fall from the tree, where ğ‘ â€” the vertex from which an apple from vertex ğ‘¥ will fall, ğ‘ â€” the vertex from which an apple from vertex ğ‘¦ will fall. Help him do this.

**Input**

The first line contains integer ğ‘¡ (1â‰¤ğ‘¡â‰¤10^4^) â€” the number of test cases.

The first line of each test case contains integer ğ‘› (2â‰¤ğ‘›â‰¤2â‹…10^5^) â€” the number of vertices in the tree.

Then there are ğ‘›âˆ’1 lines describing the tree. In line ğ‘– there are two integers ğ‘¢ğ‘– and ğ‘£ğ‘– (1â‰¤ğ‘¢ğ‘–,ğ‘£ğ‘–â‰¤ğ‘›, ğ‘¢ğ‘–â‰ ğ‘£ğ‘–) â€” edge in tree.

The next line contains a single integer ğ‘ (1â‰¤ğ‘â‰¤2â‹…10^5^) â€” the number of Timofey's assumptions.

Each of the next ğ‘ lines contains two integers ğ‘¥ğ‘– and ğ‘¦ğ‘– (1â‰¤ğ‘¥ğ‘–,ğ‘¦ğ‘–â‰¤ğ‘›) â€” the supposed vertices on which the apples will grow for the assumption .

It is guaranteed that the sum of  ğ‘› does not exceed 2â‹…10^5^. Similarly, It is guaranteed that the sum of ğ‘ does not exceed 2â‹…10^5^.

**Output**

For each Timofey's assumption output the number of ordered pairs of vertices from which apples can fall from the tree if the assumption is true on a separate line.

Examples

input

```
2
5
1 2
3 4
5 3
3 2
4
3 4
5 1
4 4
1 3
3
1 2
1 3
3
1 1
2 3
3 1
```

output

```
2
2
1
4
4
1
2
```

input

```
2
5
5 1
1 2
2 3
4 3
2
5 5
5 1
5
3 2
5 3
2 1
4 2
3
4 3
2 1
4 2
```

output

```
1
2
1
4
2
```

Note

In the first example:

- For the first assumption, there are two possible pairs of vertices from which apples can fall from the tree: (4,4),(5,4).
- For the second assumption there are also two pairs: (5,4),(5,5).
- For the third assumption there is only one pair: (4,4).
- For the fourth assumption, there are 4 pairs: (4,4),(4,5),(5,4),(5,5).

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202511192237846.png" alt="8bfe173b900d15885243bef9358a3432" style="zoom: 67%;" />

<center>Tree from the first example.</center>

For the second example, there are 4 of possible pairs of vertices from which apples can fall: (2,3),(2,2),(3,2),(3,3). For the second assumption, there is only one possible pair: (2,3). For the third assumption, there are two pairs: (3,2),(3,3).



è’‹å­è½©23å·¥å­¦é™¢ æ¸…æ™°æ˜äº†çš„ç¨‹åºï¼Œcustom stack.

```python
def build_tree(edges):
    tree = {}
    for edge in edges:
        u, v = edge
        tree.setdefault(u, []).append(v)
        tree.setdefault(v, []).append(u)
    return tree

def count_leaves(tree, leaves_count):
    stack = [(1, 0, 0)] # èŠ‚ç‚¹ï¼Œé˜¶æ®µæ ‡å¿—ï¼Œçˆ¶èŠ‚ç‚¹
    while stack:
        vertex, stage, parent = stack.pop()
        
        if stage == 0:
            stack.append((vertex, 1, parent))
            for child in tree[vertex]:
                if child != parent:
                    stack.append((child, 0, vertex))
        else:
            if len(tree[vertex]) == 1 and vertex != 1:
                leaves_count[vertex] = 1
            else:               
                child_count = 0
                for child in tree[vertex]:
                    if child != parent:
                        child_count += leaves_count[child]

                leaves_count[vertex] = child_count  # å½“å‰èŠ‚ç‚¹çš„å¶å­èŠ‚ç‚¹æ•°ç­‰äºå…¶å­èŠ‚ç‚¹çš„å¶å­èŠ‚ç‚¹æ•°ä¹‹å’Œ

def process_assumptions(tree, leaves_count, assumptions):
    for x, y in assumptions:
        result = leaves_count[x] * leaves_count[y]
        print(result)

t = int(input())
for _ in range(t):
    n = int(input())
    edges = []
    for _ in range(n - 1):
        edges.append(tuple(map(int, input().split())))

    tree = build_tree(edges)
    leaves_count = {node: 0 for node in range(1, n + 1)}
    count_leaves(tree, leaves_count)  
    # print(tree, leaves_count)
    q = int(input())
    assumptions = []
    for _ in range(q):
        assumptions.append(tuple(map(int, input().split())))

    process_assumptions(tree, leaves_count, assumptions)

```

 

ğŸš€ ä¸»è¦ä¼˜åŒ–ç‚¹

1. **é¿å…å¤šå±‚å¾ªç¯ sum(leaves[child])** â†’ æ”¹æˆæ‰‹åŠ¨ç´¯åŠ ï¼Œå‡å°‘å˜é‡å¼€é”€ã€‚
2. **å‡å°‘ Python å±€éƒ¨å˜é‡è®¿é—®å¼€é”€** â†’ å°†å¸¸ç”¨é¡¹ç»‘å®šä¸ºå±€éƒ¨å˜é‡ï¼ˆæ˜¾è‘—åŠ é€Ÿï¼‰ã€‚
3. **å‡å°‘ tuple å‹æ ˆå¼€é”€** â†’ ä½¿ç”¨ä¸¤ä¸ªå¹¶è¡Œæ ˆæˆ–ä¸€ä¸ªæ ˆå†…å­˜æ”¾ç®€çŸ­ç»“æ„ã€‚
4. **å‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€** â†’ å†…è” build_treeã€‚
5. **å¿«é€Ÿè¾“å‡º** â†’ ä½¿ç”¨ `sys.stdout.write`ã€‚
6. **å‡ ä¹æ‰€æœ‰å˜é‡æ”¹æˆæœ¬åœ°ç»‘å®š**ï¼Œåœ¨ Python ä¸­å¯å¿« 20â€“30%ã€‚

------

âœ… **æœ€ç»ˆä¼˜åŒ–ç‰ˆæœ¬ï¼ˆå«ä¸­æ–‡æ³¨é‡Šï¼‰**

```python
import sys
input = sys.stdin.readline
write = sys.stdout.write

def solve():
    t = int(input())
    for _ in range(t):
        # ---------- è¯»å…¥æ ‘ ----------
        n = int(input())
        tree = [[] for _ in range(n + 1)]
        for __ in range(n - 1):
            u, v = map(int, input().split())
            tree[u].append(v)
            tree[v].append(u)

        # ---------- DFS è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹ä¸‹é¢æœ‰å¤šå°‘å¶å­ ----------
        leaves = [0] * (n + 1)
        parent = [0] * (n + 1)

        stack = [(1, 0)]  # (node, stage)
        # stage = 0 ç¬¬ä¸€æ¬¡åˆ°è¾¾ï¼› stage = 1 å¤„ç†å®Œå­©å­å›æº¯æ—¶è®¡ç®—å¶å­æ•°

        while stack:
            node, stage = stack.pop()

            if stage == 0:
                # ç¬¬ä¸€æ¬¡é‡åˆ°è¯¥èŠ‚ç‚¹ï¼Œæ·»åŠ ä¸€ä¸ªå›æº¯æ ‡è®°
                stack.append((node, 1))

                # å‹å…¥æ‰€æœ‰å­èŠ‚ç‚¹ï¼ˆéçˆ¶èŠ‚ç‚¹ï¼‰
                for nxt in tree[node]:
                    if nxt != parent[node]:
                        parent[nxt] = node
                        stack.append((nxt, 0))

            else:
                # å›æº¯é˜¶æ®µï¼šè®¡ç®— node çš„å¶å­æ•°
                # è‹¥æ˜¯éæ ¹çš„å¶å­èŠ‚ç‚¹ï¼ˆåº¦=1ï¼‰
                if len(tree[node]) == 1 and node != 1:
                    leaves[node] = 1
                else:
                    # å¦åˆ™å¶å­æ•°ä¸ºæ‰€æœ‰å­èŠ‚ç‚¹çš„å¶å­æ•°ä¹‹å’Œ
                    total = 0
                    for nxt in tree[node]:
                        if nxt != parent[node]:
                            total += leaves[nxt]
                    leaves[node] = total

        # ---------- å¤„ç†æŸ¥è¯¢ ----------
        q = int(input())
        out = []
        for __ in range(q):
            x, y = map(int, input().split())
            out.append(str(leaves[x] * leaves[y]))

        write("\n".join(out) + "\n")


if __name__ == "__main__":
    solve()
```

------

ğŸ“Œ ä»£ç ç»“æ„äº®ç‚¹è¯´æ˜

1. **æ ‘ä½¿ç”¨ list è€Œä¸æ˜¯ dict**

æ€§èƒ½å·®è· 3~5 å€ã€‚<mark>å®æµ‹20000000é¡¹å·®ä¸å¤š</mark>ã€‚

> ```python
> import time
> 
> N = 20000000
> tree_dict = {}
> tree_list = [[] for _ in range(N+1)]
> 
> # å¡«å……
> for i in range(1, N):
>     tree_dict.setdefault(i, []).append(i+1)
>     tree_list[i].append(i+1)
> 
> # æµ‹è¯• dict è®¿é—®
> t1 = time.time()
> s = 0
> for i in range(1, N):
>     for x in tree_dict[i]:
>         s += x
> print("dict:", time.time() - t1)
> 
> # æµ‹è¯• list è®¿é—®
> t2 = time.time()
> s = 0
> for i in range(1, N):
>     for x in tree_list[i]:
>         s += x
> print("list:", time.time() - t2)
> """
> dict: 1.7978429794311523
> list: 1.6697399616241455
> """
> ```

------

2. **ä¸¤æ®µå¼è¿­ä»£ DFSï¼ˆæ¨¡æ‹Ÿé€’å½’ï¼‰**

æ„å»ºï¼š

```
å…¥æ ˆ (node, 0)
...
å›æº¯ (node,1)
```

å¯ä»¥ç¡®ä¿ï¼š

```
è®¡ç®—å¶å­æ•°æ—¶ï¼Œæ‰€æœ‰ child éƒ½å·²è®¡ç®—å®Œæˆ
```

æ— é€’å½’ã€æ— çˆ†æ ˆã€‚

------

3. **å…³é”®ä¼˜åŒ–ï¼šå‡å°‘å…¨å±€å˜é‡è®¿é—®**

Python è®¿é—® local å˜é‡æ¯” global å¿«éå¸¸å¤šã€‚

```
tree[node]
parent[node]
leaves[node]
```

å…¨éƒ¨ç»‘å®šåˆ°å±€éƒ¨ä½œç”¨åŸŸï¼Œæé«˜é€Ÿåº¦ã€‚

------

4. **æ‰¹é‡è¾“å‡º**

`sys.stdout.write` å¿«äº print
 ä¸€æ¬¡æ€§æ‹¼å¥½å­—ç¬¦ä¸²æ›´å¿«ã€‚



1765 ms ACã€‚è’‹å­è½©23å·¥å­¦é™¢ æ¸…æ™°æ˜äº†çš„ç¨‹åºï¼Œdfs with thread. åœ¨ Mac Studio (Chip: Apple M1 Ultra, macOS: Ventura 13.6.1) ä¸Šè¿è¡Œï¼Œline 4, in     `threading.stack_size(2*10**8)`, ValueError: size not valid: 200000000 bytesã€‚éœ€è¦æ˜¯4096çš„å€æ•°ï¼Œå¯ä»¥æ”¹ä¸º `threading.stack_size(2*10240*10240)`

```python
import sys
import threading
sys.setrecursionlimit(1 << 30)
threading.stack_size(2*10240*10240)	#threading.stack_size(2*10**8)

def main():
    def build_tree(edges):
        tree = {}
        for edge in edges:
            u, v = edge
            tree.setdefault(u, []).append(v)
            tree.setdefault(v, []).append(u)
        return tree

    def count_leaves(tree, vertex, parent, leaves_count):
        child_count = 0
        for child in tree[vertex]:
            if child != parent:
                child_count += count_leaves(tree, child, vertex, leaves_count)
        #if len(tree[vertex]) == 1 and vertex != parent:  # å½“å‰èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹
        if len(tree[vertex]) == 1 and vertex != 1:
            leaves_count[vertex] = 1
            return 1
        leaves_count[vertex] = child_count  # å½“å‰èŠ‚ç‚¹çš„å¶å­èŠ‚ç‚¹æ•°ç­‰äºå…¶å­èŠ‚ç‚¹çš„å¶å­èŠ‚ç‚¹æ•°ä¹‹å’Œ
        return leaves_count[vertex]

    def process_assumptions(tree, leaves_count, assumptions):
        for x, y in assumptions:
            result = leaves_count[x] * leaves_count[y]
            print(result)

    t = int(input())
    for _ in range(t):
        n = int(input())
        edges = []
        for _ in range(n - 1):
            edges.append(tuple(map(int, input().split())))

        tree = build_tree(edges)
        leaves_count = {node: 0 for node in range(1, n + 1)}
        count_leaves(tree, 1, 0, leaves_count)  # ä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†è®¡ç®—å¶å­èŠ‚ç‚¹æ•°é‡
        #print(tree, leaves_count)
        q = int(input())
        assumptions = []
        for _ in range(q):
            assumptions.append(tuple(map(int, input().split())))

        process_assumptions(tree, leaves_count, assumptions)

thread = threading.Thread(target=main)
thread.start()
thread.join()
```



> import threading
>
> help(threading.stack_size)
> Help on built-in function stack_size in module _thread:
>
> stack_size(...)
>     stack_size([size]) -> size
>
> Return the thread stack size used when creating new threads.  The
> optional size argument specifies the stack size (in bytes) to be used
> for subsequently created threads, and must be 0 (use platform or
> configured default) or a positive integer value of at least 32,768 (32k).
> If changing the thread stack size is unsupported, a ThreadError
> exception is raised.  If the specified size is invalid, a ValueError
> exception is raised, and the stack size is unmodified.  32k bytes
>  currently the minimum supported stack size value to guarantee
> sufficient stack space for the interpreter itself.
>
> Note that some platforms may have particular restrictions on values for
> the stack size, such as requiring a minimum stack size larger than 32 KiB or
> requiring allocation in multiples of the system memory page size
>
> platform documentation should be referred to for more information
> (4 KiB pages are common; using multiples of 4096 for the stack size is
> the suggested approach in the absence of more specific information).
>
> Thread stack size åœ¨macä¸Š éœ€è¦æ˜¯4096çš„å€æ•°ï¼Œå¯ä»¥æ”¹ä¸º threading.stack_size(2\*10240*10240)
>
> 2\*10240*10240 / 4096
> Out[161]: 51200.0
>
> 2*10**8 / 4096
> Out[162]: 48828.125
>
> 8372224 / 4096
> Out[163]: 2044.0



1421 ms ACã€‚

å¶å­æ•°é‡å¯ä»¥é€šè¿‡ **DFS é€’å½’** è®¡ç®—ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å¶å­æ•°ç­‰äºå…¶å­èŠ‚ç‚¹å¶å­æ•°çš„å’Œã€‚ç›´æ¥æŸ¥è¯¢ **ä¸¤èŠ‚ç‚¹çš„å¶å­æ•°**ï¼Œç„¶åç›¸ä¹˜ï¼Œé¿å…é›†åˆæ“ä½œçš„é¢å¤–å¼€é”€ã€‚ä½¿ç”¨ `sys.stdin.read()` **ä¸€æ¬¡æ€§è¯»å–è¾“å…¥**ï¼Œæé«˜å¤§æ•°æ®é‡çš„å¤„ç†æ•ˆç‡ã€‚

```python
import sys
from collections import defaultdict

def build_tree(edges, n):
    """ æ„å»ºæ ‘çš„é‚»æ¥è¡¨ """
    tree = defaultdict(list)
    for u, v in edges:
        tree[u].append(v)
        tree[v].append(u)
    return tree

def count_leaves(tree, n):
    """ è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„å¶å­æ•° (ä½¿ç”¨è¿­ä»£ DFS) """
    leaves_count = {i: 0 for i in range(1, n + 1)}
    parent = {1: -1}
    stack = [(1, 0)]  # (å½“å‰èŠ‚ç‚¹, çŠ¶æ€ 0-é¦–æ¬¡è®¿é—® 1-å›æº¯)

    order = []  # è®°å½• DFS è®¿é—®é¡ºåº

    while stack:
        node, state = stack.pop()
        if state == 0:  # é¦–æ¬¡è®¿é—®
            stack.append((node, 1))
            order.append(node)
            for child in tree[node]:
                if child == parent.get(node):  
                    continue
                parent[child] = node
                stack.append((child, 0))

    # åå‘éå† order è®¡ç®—å¶å­æ•°ã€‚ç¡®ä¿æ¯ä¸ªèŠ‚ç‚¹åœ¨å…¶æ‰€æœ‰å­èŠ‚ç‚¹ä¹‹åè¢«å¤„ç†
    for node in reversed(order):
        if len(tree[node]) == 1 and node != 1:  # å¶å­èŠ‚ç‚¹ï¼ˆæ ¹èŠ‚ç‚¹é™¤å¤–ï¼‰
            leaves_count[node] = 1
        else:
            leaves_count[node] = sum(leaves_count[child] for child in tree[node] if child != parent[node])

    return leaves_count

def process_queries(leaves_count, queries):
    """ å¤„ç†æŸ¥è¯¢ï¼Œè®¡ç®—ç­”æ¡ˆ """
    results = []
    for x, y in queries:
        results.append(str(leaves_count[x] * leaves_count[y]))
    sys.stdout.write("\n".join(results) + "\n")

def solve():
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    t = int(data[index])
    index += 1
    results = []
    
    for _ in range(t):
        n = int(data[index])
        index += 1
        
        edges = []
        for _ in range(n - 1):
            u, v = int(data[index]), int(data[index + 1])
            index += 2
            edges.append((u, v))
        
        tree = build_tree(edges, n)
        leaves_count = count_leaves(tree, n)  

        q = int(data[index])
        index += 1
        
        queries = []
        for _ in range(q):
            x, y = int(data[index]), int(data[index + 1])
            index += 2
            queries.append((x, y))
        
        process_queries(leaves_count, queries)

if __name__ == "__main__":
    #sys.setrecursionlimit(300000)  # æé«˜é€’å½’æ·±åº¦
    solve()
```

> 1. ç”¨è¿­ä»£ DFS ä»£æ›¿é€’å½’ï¼Œé¿å… **é€’å½’æ ˆæº¢å‡º**ã€‚
> 2. æ˜¾å¼å­˜å‚¨ `parent` ä»¥è·Ÿè¸ªçˆ¶èŠ‚ç‚¹ï¼Œç¡®ä¿ `leaves_count` è®¡ç®—æ­£ç¡®ã€‚
> 3. ä¼˜åŒ–æŸ¥è¯¢è®¡ç®—ï¼Œç›´æ¥è®¿é—® `leaves_count`ã€‚
>
> æ—¶é—´å¤æ‚åº¦åˆ†æ
>
> - æ„å»ºæ ‘ï¼š`O(n)`
> - è¿­ä»£ DFS è®¡ç®—å¶å­æ•°ï¼š`O(n)`
> - æŸ¥è¯¢å¤„ç†ï¼š`O(1) * q`
> - æ€»å¤æ‚åº¦ï¼š`O(n + q) â‰ˆ 2 Ã— 10âµ`ï¼Œç¬¦åˆé¢˜ç›®è¦æ±‚ã€‚






